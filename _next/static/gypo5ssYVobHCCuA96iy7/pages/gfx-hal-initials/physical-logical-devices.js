(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{"7c7i":function(e,t,n){"use strict";n.r(t),n.d(t,"record",(function(){return l})),n.d(t,"prevRecord",(function(){return u})),n.d(t,"default",(function(){return O}));var a=n("wx14"),i=n("Ff2n"),r=n("q1tI"),o=n.n(r),c=n("7ljp"),s=n("zAA7"),l=(o.a.createElement,s.a["physical-logical-devices"]),u=s.a["display-window"],p=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(c.b)("div",t)}},d=p("PolkaContainer"),b=p("H1"),m=p("Image"),h=p("Link"),f=p("Blockquote"),g={record:l,prevRecord:u},y="wrapper";function O(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(c.b)(y,Object(a.a)({},g,n,{components:t,mdxType:"MDXLayout"}),Object(c.b)(d,{pageTitle:l.title,pageDescription:l.description,keywords:["Vulkan","Basics","Fundamental","Beginner","Physical Device","Logical Device","Learn","Device Queue"],publishDate:l.createdAt,ogImage:l.ogImage,mdxType:"PolkaContainer"},Object(c.b)(b,{updatedAt:l.updatedAt,mdxType:"H1"},"T-","".concat(s.b-2),": ",l.title),Object(c.b)(m,{alt:"Get Physical Device from Backend to Logical Devices",src:"https://user-images.githubusercontent.com/11786283/82109324-a8016e80-9752-11ea-89ba-677880ada6b1.png",placeholder:"https://user-images.githubusercontent.com/11786283/82109811-ac2f8b00-9756-11ea-88db-3cbc70ee1350.png",mdxType:"Image"}),Object(c.b)("h2",null,"What is a Device"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("strong",{parentName:"li"},"Physical Device")," - represents an actual Hardware device present\nin your Computer. It usually contains details on your GPU\ndevice and APIs to create a Logical Device. Each item points\nto the GPU hardware you\nhave. So, if we have Single NVidia GPU, we get a\nsingle item, which we can ",Object(c.b)("inlineCode",{parentName:"li"},"open")," and later on use as a\n",Object(c.b)("em",{parentName:"li"},"Logical Device"),"."),Object(c.b)("li",{parentName:"ul"},Object(c.b)("strong",{parentName:"li"},"Logical Device")," - Basically, it is an application interface\nto communicate with our GPU. In ",Object(c.b)("inlineCode",{parentName:"li"},"gfx-hal")," to get a logical device,\nyou need to open ",Object(c.b)("inlineCode",{parentName:"li"},"physical_device"),".")),Object(c.b)("p",null,Object(c.b)("em",{parentName:"p"},"Details discussed later.")),Object(c.b)("h2",null,"Instantiating Adapters, Logical Device, and Device Queue Group"),Object(c.b)("p",null,"In GPU, there is no direct relation to Physical Device;\ninstead, ",Object(c.b)("inlineCode",{parentName:"p"},"gfx-hal")," provides us API to get Adapter instance,\nwhich has Physical Device instance and various Queue family\ndetails."),Object(c.b)("p",null,"I hope you have already read details on how to get a reference\nto ",Object(c.b)(h,{href:"".concat(u.link),mdxType:"Link"},"gfx-hal Instance and its Surface"),".\nIf not, please read it once before continuing."),Object(c.b)("p",null,"We would get a list of ",Object(c.b)("inlineCode",{parentName:"p"},"adapters")," from an ",Object(c.b)("inlineCode",{parentName:"p"},"instance"),"."),Object(c.b)("p",null,"We need to update our ",Object(c.b)("inlineCode",{parentName:"p"},"Renderer")," struct, and it's implementation\na bit for this."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rs"}),"struct Renderer<B: Backend> {\n    ...\n    // Device Adpter, containing Physical and Queue details\n    adapter: Adapter<B>,\n    // Logical Device object\n    device: B::Device,\n    // Queue Group for rendering reference\n    queue_group: family::QueueGroup<B>,\n}\n\nimpl<B: Backend> Renderer<B> {\n    fn new(instance: B::Instance, surface: B::Surface) -> Self {\n        let mut adapters = instance.enumerate_adapters();\n        let (memory_types, limits, adapter) = {\n            let adapter = adapters.remove(0);\n            (\n                adapter.physical_device.memory_properties().memory_types,\n                adapter.physical_device.limits(),\n                adapter,\n            )\n        };\n\n        let (device, queue_group, supported_family) = {\n            let supported_family = adapter.queue_families.iter()\n                .find(|family| {\n                    surface.supports_queue_family(family) && family.queue_type().supports_graphics()\n                })\n                .unwrap();\n\n            let mut gpu = unsafe {\n                adapter.physical_device\n                    .open(&[(supported_family, &[1.0])], Features::empty())\n                    .unwrap()\n            };\n\n            (\n                gpu.device,\n                gpu.queue_groups.pop().unwrap(),\n                supported_family,\n            )\n        };\n\n        Renderer {\n            ...\n            adapter,\n            device,\n            queue_group,\n        }\n    }\n}\n...\n")),Object(c.b)("h3",null,"Code Breakdown"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("inlineCode",{parentName:"li"},"enumerate_adapters")," is used to get a list of available adapters,\neach containing one Physical Device resource in it. From the collection\nof adapters, we can get the ",Object(c.b)("inlineCode",{parentName:"li"},"adapter")," that we need."),Object(c.b)("li",{parentName:"ul"},"Getting ",Object(c.b)("inlineCode",{parentName:"li"},"supported_family")," from a list of Queue Families that our\nGPU supports. Queues and Queue Families to be discussed later\nin this Chapter, for now, understand that ",Object(c.b)("inlineCode",{parentName:"li"},"supported_family"),"\nis a Family of Queues that understands the Instructions\nwe want to run on GPU."),Object(c.b)("li",{parentName:"ul"},"Physical Device resource uses ",Object(c.b)("inlineCode",{parentName:"li"},"supported_family")," to get\nsupported Logical Device and Queue Groups (details to be\ndiscussed later). ",Object(c.b)("inlineCode",{parentName:"li"},"Features::empty()")," denotes that we want\ndefault features enabled for Logical Device.")),Object(c.b)("h2",null,"What details does an ",Object(c.b)("inlineCode",{parentName:"h2"},"Adapter")," have"),Object(c.b)(f,{type:"warn",mdxType:"Blockquote"},"The following are not a complete list of Adapter properties. They mostly consist of all those properties that we have already described earlier. We are just discussing them in detail here."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'// `adapter.info`: Adapter Info\n{\n  name: "GeForce GTX 1060 6GB",\n  vendor: 4310,\n  device: 7114,\n  // Enum - { Other = 0, IntegratedGpu = 1, DiscreteGpu = 2, VirtualGpu = 3, Cpu = 4 }\n  device_type: DiscreteGpu,\n}\n')),Object(c.b)("p",null,"GPU info is quite clear. Getting info is simple - ",Object(c.b)("inlineCode",{parentName:"p"},"adapter.info"),".\nIt basically gives us details on GPU Hardware."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// `adapter.physical_device.limits()`: Physical Device Limits,\n{\n  max_image_1d_size: 16384,\n  max_image_2d_size: 16384,\n  max_image_3d_size: 2048,\n  max_image_cube_size: 16384,\n  max_image_array_layers: 2048,\n  max_texel_elements: 268435456,\n  // ...and more\n}\n")),Object(c.b)("p",null,"GPU limits are also self-explanatory. It gives us a struct\ncontaining details on GPU Memory, Concurrency limits."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// Memory Types: `adapter.physical_device.memory_properties().memory_types`\n[\n    MemoryType {\n        properties: DEVICE_LOCAL,\n        heap_index: 0,\n    },\n    MemoryType {\n        properties: CPU_VISIBLE | COHERENT,\n        heap_index: 1,\n    },\n    //...more\n]\n")),Object(c.b)("p",null,"I won't comment too much on ",Object(c.b)("inlineCode",{parentName:"p"},"MemoryType"),"s, as details on\n",Object(c.b)("inlineCode",{parentName:"p"},"DEVICE_LOCAL")," or ",Object(c.b)("inlineCode",{parentName:"p"},"CPU_VISIBLE")," MemoryTypes is unknown to me\nas well at this point."),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},Object(c.b)("strong",{parentName:"p"},"Direct Quote from gfx-hal examples")),Object(c.b)("p",{parentName:"blockquote"},Object(c.b)("em",{parentName:"p"},"Using CPU_VISIBLE memory is convenient because it can be"),"\n",Object(c.b)("em",{parentName:"p"},"directly memory-mapped and easily updated by the CPU, but it is very slow and so should"),"\n",Object(c.b)("em",{parentName:"p"},"only be used for small pieces of data that need to be updated very frequently."),"\n",Object(c.b)("em",{parentName:"p"},"For something like a vertex buffer that may be much larger and should not change"),"\n",Object(c.b)("em",{parentName:"p"},"frequently, you should instead use a DEVICE_LOCAL buffer that gets filled by"),"\n",Object(c.b)("em",{parentName:"p"},"copying data from a CPU_VISIBLE staging buffer."))),Object(c.b)("p",null,"From the above Quote, I can get that memory_types are used to create\nspecific types of buffers that are efficient in some places\nand not in the others."),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},"I can understand if things are getting too intense. Be patient\nand force yourself to complete the whole tutorial.\nUltimately the results will be excellent. Once we are done\nshowing graphics on the Window, everything here will make sense.")),Object(c.b)("hr",null),Object(c.b)("h2",null,"Logical Device"),Object(c.b)(m,{alt:"How to get Logical Devices from Physical Device",src:"https://user-images.githubusercontent.com/11786283/77247969-01ba5080-6c5c-11ea-8202-3c83e1a25b51.png",placeholder:"https://user-images.githubusercontent.com/11786283/82109903-8951a680-9757-11ea-8acc-b88bbc173fce.png",mdxType:"Image"}),Object(c.b)("p",null,"As you can see from the above image, a logical device is\nnothing but a representation of an actual physical device."),Object(c.b)("p",null,"Physical device (like NVidia GPU) can be used for various things like\nGames, Graphics Rendering, Data Mining, Machine Learning, and more. This vast\nrange of use-cases is possible in GPU only due to its support for both\nCPU intensive tasks (tasks that do a single operation but benefit with GPU's\nabundant number of cores for parallel operations),\nas well as GPU intensive tasks. For us, we are currently\nlooking for a Device Capability specific to Graphics intensive task."),Object(c.b)("p",null,"Thus Logical Device is a representation of Physical Device, which has\nsupport for specific capabilities (thus, we used ",Object(c.b)("inlineCode",{parentName:"p"},"supported_family"),"\nto open a Logical Device) that it works on for the\ntime App is running."),Object(c.b)("p",null,"Logical Devices are used to create and manage different resources,\nlike buffers, shader programs, and textures."),Object(c.b)("h2",null,"Device Queues & Queue Families"),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"What are Device Queues anyways??"),"\nAs the name suggests, it's just a Queue.\nEvery GPU driver provides us with Queues bound to its\nhardware, which can take Commands from our application\nand process it parallelly.\nThus, we use queues to process graphics commands parallelly."),Object(c.b)("p",null,Object(c.b)("strong",{parentName:"p"},"What are Queues Families anyways??"),"\nQueue Families are a collection of support details for a GPU.\nIt points out what kind of work our GPU hardware\ncan handle, like handling CPU compute operations,\nI/O transfer operations, GPU graphics/render operations, and more.\nIf our GPU supports all of them, then we need\nto choose between various queue families to decide on\nwhat particular operations we want to do via our Logical\nDevice anytime."),Object(c.b)("p",null,"Cool! Let's now discuss our above Code example."),Object(c.b)("p",null,"Getting a ",Object(c.b)("inlineCode",{parentName:"p"},"supported_family")," was crucial because it helped us\nget a specific Logical Device (",Object(c.b)("inlineCode",{parentName:"p"},"gpu.device"),") and Queue groups\n(",Object(c.b)("inlineCode",{parentName:"p"},"gpu.queue_groups"),"). Supported Family defines what kind of\noperation we want to perform using the device and queues."),Object(c.b)("p",null,"Queue Groups are used to get ",Object(c.b)("inlineCode",{parentName:"p"},"queues")," that\nkeep hold of our commands from a ",Object(c.b)("em",{parentName:"p"},"Command Buffer"),"."),Object(c.b)("blockquote",null,Object(c.b)("p",{parentName:"blockquote"},Object(c.b)("strong",{parentName:"p"},"Note:")," Opening a Physical Device instance to get a Logical Device instance\nis ",Object(c.b)("inlineCode",{parentName:"p"},"unsafe"),". Thus that code-block was wrapped inside ",Object(c.b)("inlineCode",{parentName:"p"},"unsafe {}")," block."),Object(c.b)("p",{parentName:"blockquote"},"To get details on ",Object(c.b)("inlineCode",{parentName:"p"},"unsafe")," usage, read ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html"}),"Rust Nomicon"),".")),Object(c.b)("h3",null,"How do they look internally:"),Object(c.b)("p",null,"Logical Device representation is quite complex; thus,\nI won't describe it here.\nBetter to read ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.rs/gfx-hal/0.5.0/gfx_hal/device/trait.Device.html"}),"Device Docs"),",\nand understand how to use its APIs."),Object(c.b)("p",null,"Queue Families are a collection of details on supported\nQueue Groups in a GPU."),Object(c.b)("p",null,"(Since I was using MacOS) I got ",Object(c.b)("inlineCode",{parentName:"p"},"supported_family")," as shown below:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-log"}),"2020-05-16T19:22:41.155852+05:30 DEBUG enumerate_devices - >>>>>>> Queue Family Type:: General\n2020-05-16T19:22:41.155987+05:30 DEBUG enumerate_devices - >>>>>>> Queue Max Queues:: 1\n2020-05-16T19:22:41.156018+05:30 DEBUG enumerate_devices - >>>>>>> Queue Id:: QueueFamilyId(0)\n")),Object(c.b)("p",null,"where if you see the family id, that points to the first Queue group, in\n",Object(c.b)("inlineCode",{parentName:"p"},"gpu.queue_groups"),", which contains the supported queues for creating and\nmanaging different resources."),Object(c.b)("p",null,"The above representation is for ",Object(c.b)("inlineCode",{parentName:"p"},"Metal")," GPU driver in MacOS,\nwhich is very different than actual\nVulkan Queue Family, which you can see in any Linux OS."),Object(c.b)("p",null,"Please do not get confused with the above log,\nas it differs from system to system.\nFollowing is a representation of all ",Object(c.b)("inlineCode",{parentName:"p"},"adapter.queue_families"),"\n(on Linux for Vulkan Backend)."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// Queue Families\n[\n  {\n    properties: {\n      queue_flags: GRAPHICS | COMPUTE | TRANSFER | SPARSE_BINDING,\n      queue_count: 16,\n      timestamp_valid_bits: 64,\n      min_image_transfer_granularity: {\n        width: 1,\n        height: 1,\n        depth: 1,\n      },\n    },\n    device: 0x00005622e6d7d271,\n    index: 0,\n  },\n  {\n    properties: {\n      queue_flags: TRANSFER,\n      queue_count: 1,\n      timestamp_valid_bits: 64,\n      min_image_transfer_granularity: {\n        width: 1,\n        height: 1,\n        depth: 1,\n      },\n    },\n    device: 0x00005622e6d7d270,\n    index: 1,\n  }\n]\n")),Object(c.b)("p",null,"For a detailed explanation on Queue Family, see this ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://stackoverflow.com/a/55273688/2849127"}),"Stackoverflow thread")),Object(c.b)("hr",null),Object(c.b)("h2",null,"Code"),Object(c.b)("p",null,"You can find the full code for this Doc,\nhere ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Shub1427/rustschool/blob/master/gui/draw-cube/src/002-enumerate_devices/main.rs"}),"002-enumerate_devices")),Object(c.b)("p",null,"To run that code:"),Object(c.b)("p",null,Object(c.b)("inlineCode",{parentName:"p"},"cargo run --bin enumerate_devices --features=metal")),Object(c.b)("p",null,Object(c.b)("em",{parentName:"p"},"We don't have any change in the output in this Chapter."))))}O.isMDXComponent=!0},"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n("q1tI"),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),u=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):c({},t,{},e)),n},p=function(e){var t=u(e.components);return(i.a.createElement(l.Provider,{value:t},e.children))},d="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,m=p["".concat(o,".").concat(d)]||p[d]||b[d]||r;return n?i.a.createElement(m,c({ref:t},l,{components:n})):i.a.createElement(m,c({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[d]="string"===typeof e?e:a,o[1]=c;for(var l=2;l<r;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var a=n("zLVn");function i(e,t){if(null==e)return{};var n,i,r=Object(a.a)(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}},Q88C:function(e,t,n){"use strict";var a;n.d(t,"a",(function(){return a})),function(e){e.TUTORIAL="tutorial",e.PROJECT="project",e.RESEARCH="research",e.RUST="rust",e.JS="javascript",e.REACT="reactjs",e.GFX_HAL="gfx-hal"}(a||(a={}))},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},hzGs:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/gfx-hal-initials/physical-logical-devices",function(){return n("7c7i")}])},wx14:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return a}))},zAA7:function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return r}));var a=n("Q88C"),i={"display-window":{key:"display-window",link:"/gfx-hal-initials/display-window",title:"Setup & Display Blank Window",description:"Learn Displaying a Blank Window using winit and bind it to gfx-hal surface instance",ogImage:"https://user-images.githubusercontent.com/11786283/82109997-98852400-9758-11ea-84a0-aa3996c67f86.jpg",tags:[a.a.RUST],createdAt:new Date("2020/04/25 17:00:00"),updatedAt:new Date("2020/05/28 23:50:00"),isPublished:!0},"physical-logical-devices":{key:"physical-logical-devices",link:"/gfx-hal-initials/physical-logical-devices",title:"Adapters & Physical/Logical Devices & Device Queues",description:"Learn to Instantiate Vulkan Physical/Logical Devices and get Device Queue from gfx-hal adapters",ogImage:"https://user-images.githubusercontent.com/11786283/82111231-485e8f80-9761-11ea-9f21-8843d4a66752.jpg",tags:[a.a.TUTORIAL,a.a.RUST,a.a.GFX_HAL],createdAt:new Date("2020/05/16 8:45:00"),updatedAt:new Date("2020/05/29 9:25:00"),isPublished:!0},"swap-chain":{key:"swap-chain",link:"/gfx-hal-initials/swap-chain",title:"SwapChain and Image Views in gfx-hal",description:"Learning about Swapchain, Double Buffering and Image Views. Understanding the implementation of SwapChain in gfx-hal",ogImage:"https://user-images.githubusercontent.com/11786283/82640938-22396380-9c29-11ea-9ee5-9a7fc01920da.jpg",tags:[a.a.TUTORIAL,a.a.RUST,a.a.GFX_HAL],createdAt:new Date("2020/05/22 10:20:00"),updatedAt:new Date("2020/05/23 14:30:00"),isPublished:!0},"command-buffers":{key:"command-buffers",link:"/gfx-hal-initials/command-buffers",title:"Command Buffers & Pool",description:"Understanding Command Pools and Command Buffers in Vulkan and gfx-hal",ogImage:"https://user-images.githubusercontent.com/11786283/82124794-f0567600-97be-11ea-9023-ea1467a6b734.jpg",tags:[a.a.TUTORIAL,a.a.RUST,a.a.GFX_HAL],createdAt:new Date("2020/05/16 21:45:00"),updatedAt:new Date("2020/05/16 21:45:00"),isPublished:!0},shaders:{key:"shaders",link:"/gfx-hal-initials/shaders",title:"Shaders",description:"Understanding Shaders & writing minimal Shader using GLSL Shading language",ogImage:"https://user-images.githubusercontent.com/11786283/82640938-22396380-9c29-11ea-9ee5-9a7fc01920da.jpg",tags:[a.a.TUTORIAL,a.a.RUST,a.a.GFX_HAL],createdAt:new Date("2020/05/23 19:30:00"),updatedAt:new Date("2020/05/23 19:35:00"),isPublished:!0}},r=Object.keys(i).length},zLVn:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}n.d(t,"a",(function(){return a}))}},[["hzGs",0,1]]]);