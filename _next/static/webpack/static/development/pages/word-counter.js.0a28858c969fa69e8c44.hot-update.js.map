{"version":3,"file":"static/webpack/static/development/pages/word-counter.js.0a28858c969fa69e8c44.hot-update.js","sources":["webpack:///./pages/word-counter.md"],"sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\nconst PolkaContainer = makeShortcode(\"PolkaContainer\");\nconst NoteSubtitle = makeShortcode(\"NoteSubtitle\");\nconst Blockquote = makeShortcode(\"Blockquote\");\nconst InlineCode = makeShortcode(\"InlineCode\");\nconst Link = makeShortcode(\"Link\");\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <PolkaContainer mdxType=\"PolkaContainer\">\n      <h1>{`Word Counter`}</h1>\n      <NoteSubtitle date={new Date(\"2020/04/26\")} totalWords={564} mdxType=\"NoteSubtitle\" />\n      <p>{`This is a fun script, that I am trying out to learn rust. Also benifitting myself,\nwith a script that will automate to get an approx. count of words from my MDX notes,\nwhich later on will help me to get the read time per notes.`}</p>\n      <Blockquote type=\"warn\" mdxType=\"Blockquote\">\nThe Word Counter code is written in 2hrs time, and is not optimal. It uses\nbrute force to remove templates matched by different <InlineCode mdxType=\"InlineCode\">regex</InlineCode>\nexpressions, one by one in sequence. I will someday improve this script, to use AST\nfor better perfomance and accurate results.\n        <br />\n        <br />\n        <i>\n  References to read later:\n  <br />\n  <Link href=\"https://ruslanspivak.com/lsbasi-part1/\" target=\"_blank\" mdxType=\"Link\">\n    Let's build an Interpreter\n  </Link>\n  &nbsp;and&nbsp;\n  <Link href=\"https://compilers.iecc.com/crenshaw/\" target=\"_blank\" mdxType=\"Link\">\n    Let's build a Compiler\n  </Link>\n  .\n        </i>\n      </Blockquote>\n      <h2>{`Code Breakup`}</h2>\n      <p>{`First of all, I am using `}<inlineCode parentName=\"p\">{`regex`}</inlineCode>{` crate, which is offical crate support by Rust.`}</p>\n      <p>{`Using `}<inlineCode parentName=\"p\">{`regex`}</inlineCode>{` is simple and it uses `}<a parentName=\"p\" {...{\n          \"href\": \"https://github.com/google/re2/wiki/Syntax\"\n        }}>{`RE2`}</a>{` syntax,\nwhich is a superset for Javascript `}<a parentName=\"p\" {...{\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\"\n        }}>{`RegExp`}</a>{`.`}</p>\n      <p>{`Reading data from `}<inlineCode parentName=\"p\">{`stdin`}</inlineCode>{`, required as we will use our build as a pipe function later:`}</p>\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-rs\"\n        }}>{`use std::io::{self, Read};\n...\nlet mut buffer = String::new();\nio::stdin().read_to_string(&mut buffer)?;\n...\n`}</code></pre>\n      <p>{`Now we need few regular expressions to be pre-compiled, so as to use them later`}</p>\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-rs.true\"\n        }}>{`use regex::{Regex, RegexBuilder, Captures};\n...\nlet re1 = Regex::new(r\"<\\\\s*[^>]*>(.*?)<\\\\s*/.*\\\\s*>\").unwrap();\nlet re2 = Regex::new(r\"<\\\\s*[^>]*/?>|<\\\\s*/.*\\\\s*>\").unwrap();\nlet re3 = RegexBuilder::new(r\"^(\\`{3}\\\\w)[^\\`]*(\\`{3})$\")\n    .multi_line(true)\n    .dot_matches_new_line(true)\n    .build()\n...\n`}</code></pre>\n      <p><strong parentName=\"p\">{`Line 3.`}</strong>{` creates a regex for all HTML Container Tags, extracting out the inner strings,\nso as to word count them later.`}</p>\n      <p><strong parentName=\"p\">{`Line 4.`}</strong>{` creates a regex from all HTML Empty Tags and previously uncatched Opening/Closing Tags.`}</p>\n      <p><strong parentName=\"p\">{`Line 5.`}</strong>{` helps to create a multi-line flagged regexp, so as to match all the Code Blocks.`}</p>\n      <blockquote>\n        <p parentName=\"blockquote\">{`Note: Code Diff Blocks are still remaining to be checked. Currently the content inside Code\nDiff block will be part of Word counts.`}</p>\n      </blockquote>\n      <p>{`All the above regex will later on be used to replace their matches with empty string,\nso as to remove them. üéâ ‚úåÔ∏è`}</p>\n      <h3>{`Some more regex:`}</h3>\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-rs\"\n        }}>{`let return_to_space = Regex::new(r\"\\\\n\").unwrap();\nlet space_re = Regex::new(r\"\\\\s\").unwrap();\n`}</code></pre>\n      <p><inlineCode parentName=\"p\">{`return_to_space`}</inlineCode>{` regex will be used to remove all the remaing `}<inlineCode parentName=\"p\">{`return`}</inlineCode>{`s from the output string,\nthat we will get, using previous regex.`}</p>\n      <p><inlineCode parentName=\"p\">{`space_re`}</inlineCode>{` regex, will later on be used to filter out extra spaces, so as to improve word count\naccuracy.`}</p>\n      <h3>{`Final Regex to extract Words`}</h3>\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-rs\"\n        }}>{`let word_counter_re = RegexBuilder::new(r\"[^\\\\s#\\\\*]*\")\n  .multi_line(true)\n  .dot_matches_new_line(true)\n  .build()\n  .unwrap();\n`}</code></pre>\n      <p>{`Do note, above regex is not for pure words, as in our `}<inlineCode parentName=\"p\">{`mdx`}</inlineCode>{` files, we have inline code-snippets,\nand more stuff, which breaks if `}<inlineCode parentName=\"p\">{`\\\\w+`}</inlineCode>{` is directly used. Thus we needed to get all chars which are\nnot space, `}<inlineCode parentName=\"p\">{`#`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`*`}</inlineCode>{`. I know, this regex might be incomplete, or needs more chars for proper filter,\nbut for now it's fine as we need approximate results, not accurate.`}</p>\n      <br />\n      <p>{`Finally, using the above regex and filtering our extra spaces, we can get an approximate\ncount of all the words present in our Notes, so as to later on generate Read Time for\nour Notes.`}</p>\n      <br />\n      <blockquote>\n        <p parentName=\"blockquote\">{`You can find full code, for this note, `}<a parentName=\"p\" {...{\n            \"href\": \"https://github.com/Shub1427/shub1427.github.io/tree/react/scripts/src/bin/word-counter.rs\"\n          }}>{`here`}</a>{`.`}</p>\n      </blockquote>\n      <hr></hr>\n    </PolkaContainer>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAFA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;;;;A","sourceRoot":""}