{"version":3,"file":"static/webpack/static/development/pages/word-counter.js.38384399f205b52c8e27.hot-update.js","sources":["webpack:///./pages/word-counter.md"],"sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\nconst PolkaContainer = makeShortcode(\"PolkaContainer\");\nconst Blockquote = makeShortcode(\"Blockquote\");\nconst InlineCode = makeShortcode(\"InlineCode\");\nconst Link = makeShortcode(\"Link\");\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <PolkaContainer mdxType=\"PolkaContainer\">\n      <h1>{`Word Counter`}</h1>\n      <p>{`This is a fun script, that I am trying out to learn rust. Also benifitting myself,\nwith a script that will automate to get an approx. count of words from my MDX notes,\nwhich later on will help me to get the read time per notes.`}</p>\n      <Blockquote type=\"warn\" mdxType=\"Blockquote\">\nThe Word Counter code is written in 2hrs time, and is not optimal. It uses\nbrute force to remove templates matched by different <InlineCode mdxType=\"InlineCode\">regex</InlineCode>\nexpressions, one by one in sequence. I will someday improve this script, to use AST\nfor better perfomance and accurate results.\n        <br />\n        <br />\n        <i>\n  References to read later:\n  <br />\n  <Link href=\"https://ruslanspivak.com/lsbasi-part1/\" target=\"_blank\" mdxType=\"Link\">\n    Let's build an Interpreter\n  </Link>\n  &nbsp;and&nbsp;\n  <Link href=\"https://compilers.iecc.com/crenshaw/\" target=\"_blank\" mdxType=\"Link\">\n    Let's build a Compiler\n  </Link>\n  .\n        </i>\n      </Blockquote>\n      <h2>{`Code Breakup`}</h2>\n      <p>{`First of all, I am using `}<inlineCode parentName=\"p\">{`regex`}</inlineCode>{` crate, which is offical crate support by Rust.`}</p>\n      <p>{`Using `}<inlineCode parentName=\"p\">{`regex`}</inlineCode>{` is simple and it uses `}<a parentName=\"p\" {...{\n          \"href\": \"https://github.com/google/re2/wiki/Syntax\"\n        }}>{`RE2`}</a>{` syntax,\nwhich is a superset for Javascript `}<a parentName=\"p\" {...{\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\"\n        }}>{`RegExp`}</a>{`.`}</p>\n      <p>{`Reading data from `}<inlineCode parentName=\"p\">{`stdin`}</inlineCode>{`, required as we will use our build as a pipe function later:`}</p>\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-rs\"\n        }}>{`use std::io::{self, Read};\n...\nlet mut buffer = String::new();\nio::stdin().read_to_string(&mut buffer)?;\n...\n`}</code></pre>\n      <p>{`Now we need few regular expressions to be pre-compiled, so as to use them later`}</p>\n      <pre><code parentName=\"pre\" {...{\n          \"className\": \"language-rs.true\"\n        }}>{`use regex::{Regex, RegexBuilder, Captures};\n...\nlet re1 = Regex::new(r\"<\\\\s*[^>]*>(.*?)<\\\\s*/.*\\\\s*>\").unwrap();\nlet re2 = Regex::new(r\"<\\\\s*[^>]*/?>|<\\\\s*/.*\\\\s*>\").unwrap();\nlet re3 = RegexBuilder::new(r\"^(\\`{3}\\\\w)[^\\`]*(\\`{3})$\")\n    .multi_line(true)\n    .dot_matches_new_line(true)\n    .build()\n...\n`}</code></pre>\n      <p>{`Line 3. creates a regex for all HTML Container Tags, extracting out the inner strings,\nso as to word count them later.`}</p>\n      <p>{`Line 4. creates a regex from all HTML Empty Tags and previously uncatched Opening/Closing Tags.`}</p>\n      <p>{`Line 5. helps to create a multi-line flagged regexp, so as to match all the Code Blocks.`}</p>\n      <blockquote>\n        <p parentName=\"blockquote\">{`Note: Code Diff Blocks are still remaining to be checked. Currently the content inside Code\nDiff block will be part of Word counts.`}</p>\n      </blockquote>\n      <p>{`All the above regex will later on be used to replace their matches with empty string,\nso as to remove them.`}</p>\n    </PolkaContainer>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAFA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAEA;AACA;;;;A","sourceRoot":""}