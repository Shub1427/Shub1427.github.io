webpackHotUpdate("static/development/pages/_app.js",{

/***/ "./components/progressive-image.tsx":
/*!******************************************!*\
  !*** ./components/progressive-image.tsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Image; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_progressive_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-progressive-image */ \"./node_modules/react-progressive-image/dist.js\");\n/* harmony import */ var react_progressive_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_progressive_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_zoom_pan_pinch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-zoom-pan-pinch */ \"./node_modules/react-zoom-pan-pinch/dist/index.es.js\");\n/* harmony import */ var _material_ui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/core */ \"./node_modules/@material-ui/core/esm/index.js\");\nvar _jsxFileName = \"/Users/subroto.biswas/Subroto/shub1427.github.io/components/progressive-image.tsx\",\n    _s = $RefreshSig$();\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n\nconst useStyles = Object(_material_ui_core__WEBPACK_IMPORTED_MODULE_4__[\"makeStyles\"])({\n  root: {\n    position: 'relative',\n    width: '100%',\n    margin: '32px 0'\n  },\n  image: {\n    width: '100%',\n    filter: 'blur(0)',\n    transition: '0.3s ease-out'\n  },\n  blur: {\n    filter: 'blur(3px)'\n  },\n  description: {\n    margin: 0,\n    textAlign: 'center',\n    fontStyle: 'italic',\n    fontWeight: 400,\n    fontSize: '0.8rem',\n    color: '#aaa'\n  }\n});\nfunction Image(props) {\n  _s();\n\n  const classes = useStyles();\n  const rootClasses = classnames__WEBPACK_IMPORTED_MODULE_1___default()(classes.root);\n  return __jsx(\"div\", {\n    className: rootClasses,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 41,\n      columnNumber: 5\n    }\n  }, __jsx(react_progressive_image__WEBPACK_IMPORTED_MODULE_2___default.a, {\n    src: props.src,\n    placeholder: props.placeholder,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 42,\n      columnNumber: 7\n    }\n  }, (src, loading) => {\n    const rootClasses = classnames__WEBPACK_IMPORTED_MODULE_1___default()(classes.image, {\n      [classes.blur]: loading\n    });\n    return __jsx(react_zoom_pan_pinch__WEBPACK_IMPORTED_MODULE_3__[\"TransformWrapper\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 48,\n        columnNumber: 13\n      }\n    }, __jsx(react_zoom_pan_pinch__WEBPACK_IMPORTED_MODULE_3__[\"TransformComponent\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 49,\n        columnNumber: 15\n      }\n    }, __jsx(\"img\", {\n      className: rootClasses,\n      src: src,\n      alt: props.alt,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 17\n      }\n    })));\n  }), __jsx(_material_ui_core__WEBPACK_IMPORTED_MODULE_4__[\"Typography\"], {\n    className: classes.description,\n    variant: \"body2\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56,\n      columnNumber: 7\n    }\n  }, props.alt));\n}\n\n_s(Image, \"8g5FPXexvSEOsxdmU7HicukHGqY=\", false, function () {\n  return [useStyles];\n});\n\n_c = Image;\n\nvar _c;\n\n$RefreshReg$(_c, \"Image\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports_1 = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports_1;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3Byb2dyZXNzaXZlLWltYWdlLnRzeD81ZmExIl0sIm5hbWVzIjpbInVzZVN0eWxlcyIsIm1ha2VTdHlsZXMiLCJyb290IiwicG9zaXRpb24iLCJ3aWR0aCIsIm1hcmdpbiIsImltYWdlIiwiZmlsdGVyIiwidHJhbnNpdGlvbiIsImJsdXIiLCJkZXNjcmlwdGlvbiIsInRleHRBbGlnbiIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiLCJmb250U2l6ZSIsImNvbG9yIiwiSW1hZ2UiLCJwcm9wcyIsImNsYXNzZXMiLCJyb290Q2xhc3NlcyIsImN4Iiwic3JjIiwicGxhY2Vob2xkZXIiLCJsb2FkaW5nIiwiYWx0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQSxNQUFNQSxTQUFTLEdBQUdDLG9FQUFVLENBQUM7QUFDM0JDLE1BQUksRUFBRTtBQUNKQyxZQUFRLEVBQUUsVUFETjtBQUVKQyxTQUFLLEVBQUUsTUFGSDtBQUdKQyxVQUFNLEVBQUU7QUFISixHQURxQjtBQU0zQkMsT0FBSyxFQUFFO0FBQ0xGLFNBQUssRUFBRSxNQURGO0FBRUxHLFVBQU0sRUFBRSxTQUZIO0FBR0xDLGNBQVUsRUFBRTtBQUhQLEdBTm9CO0FBVzNCQyxNQUFJLEVBQUU7QUFDSkYsVUFBTSxFQUFFO0FBREosR0FYcUI7QUFjM0JHLGFBQVcsRUFBRTtBQUNYTCxVQUFNLEVBQUUsQ0FERztBQUVYTSxhQUFTLEVBQUUsUUFGQTtBQUdYQyxhQUFTLEVBQUUsUUFIQTtBQUlYQyxjQUFVLEVBQUUsR0FKRDtBQUtYQyxZQUFRLEVBQUUsUUFMQztBQU1YQyxTQUFLLEVBQUU7QUFOSTtBQWRjLENBQUQsQ0FBNUI7QUE0QmUsU0FBU0MsS0FBVCxDQUFlQyxLQUFmLEVBQW1DO0FBQUE7O0FBQ2hELFFBQU1DLE9BQU8sR0FBR2xCLFNBQVMsRUFBekI7QUFDQSxRQUFNbUIsV0FBVyxHQUFHQyxpREFBRSxDQUFDRixPQUFPLENBQUNoQixJQUFULENBQXRCO0FBQ0EsU0FDRTtBQUFLLGFBQVMsRUFBRWlCLFdBQWhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLDhEQUFEO0FBQWtCLE9BQUcsRUFBRUYsS0FBSyxDQUFDSSxHQUE3QjtBQUFrQyxlQUFXLEVBQUVKLEtBQUssQ0FBQ0ssV0FBckQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNHLENBQUNELEdBQUQsRUFBY0UsT0FBZCxLQUFtQztBQUNsQyxVQUFNSixXQUFXLEdBQUdDLGlEQUFFLENBQUNGLE9BQU8sQ0FBQ1osS0FBVCxFQUFnQjtBQUNwQyxPQUFDWSxPQUFPLENBQUNULElBQVQsR0FBZ0JjO0FBRG9CLEtBQWhCLENBQXRCO0FBR0EsV0FDRSxNQUFDLHFFQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FDRSxNQUFDLHVFQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FDRTtBQUFLLGVBQVMsRUFBRUosV0FBaEI7QUFBNkIsU0FBRyxFQUFFRSxHQUFsQztBQUF1QyxTQUFHLEVBQUVKLEtBQUssQ0FBQ08sR0FBbEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQURGLENBREYsQ0FERjtBQU9ELEdBWkgsQ0FERixFQWVFLE1BQUMsNERBQUQ7QUFBWSxhQUFTLEVBQUVOLE9BQU8sQ0FBQ1IsV0FBL0I7QUFBNEMsV0FBTyxFQUFDLE9BQXBEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDR08sS0FBSyxDQUFDTyxHQURULENBZkYsQ0FERjtBQXFCRDs7R0F4QnVCUixLO1VBQ05oQixTOzs7S0FETWdCLEsiLCJmaWxlIjoiLi9jb21wb25lbnRzL3Byb2dyZXNzaXZlLWltYWdlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvZ3Jlc3NpdmVJbWFnZSwge1xuICBQcm9ncmVzc2l2ZUltYWdlUHJvcHMsXG59IGZyb20gJ3JlYWN0LXByb2dyZXNzaXZlLWltYWdlJztcbmltcG9ydCB7IFRyYW5zZm9ybVdyYXBwZXIsIFRyYW5zZm9ybUNvbXBvbmVudCB9IGZyb20gXCJyZWFjdC16b29tLXBhbi1waW5jaFwiO1xuaW1wb3J0IHsgbWFrZVN0eWxlcywgVHlwb2dyYXBoeSB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlJztcblxuY29uc3QgdXNlU3R5bGVzID0gbWFrZVN0eWxlcyh7XG4gIHJvb3Q6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIG1hcmdpbjogJzMycHggMCcsXG4gIH0sXG4gIGltYWdlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBmaWx0ZXI6ICdibHVyKDApJyxcbiAgICB0cmFuc2l0aW9uOiAnMC4zcyBlYXNlLW91dCcsXG4gIH0sXG4gIGJsdXI6IHtcbiAgICBmaWx0ZXI6ICdibHVyKDNweCknLFxuICB9LFxuICBkZXNjcmlwdGlvbjoge1xuICAgIG1hcmdpbjogMCxcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgZm9udFdlaWdodDogNDAwLFxuICAgIGZvbnRTaXplOiAnMC44cmVtJyxcbiAgICBjb2xvcjogJyNhYWEnLFxuICB9LFxufSk7XG5cbmludGVyZmFjZSBJSW1hZ2VQcm9wcyBleHRlbmRzIFByb2dyZXNzaXZlSW1hZ2VQcm9wcyB7XG4gIGFsdDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbWFnZShwcm9wczogSUltYWdlUHJvcHMpIHtcbiAgY29uc3QgY2xhc3NlcyA9IHVzZVN0eWxlcygpO1xuICBjb25zdCByb290Q2xhc3NlcyA9IGN4KGNsYXNzZXMucm9vdCk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3Jvb3RDbGFzc2VzfT5cbiAgICAgIDxQcm9ncmVzc2l2ZUltYWdlIHNyYz17cHJvcHMuc3JjfSBwbGFjZWhvbGRlcj17cHJvcHMucGxhY2Vob2xkZXJ9PlxuICAgICAgICB7KHNyYzogc3RyaW5nLCBsb2FkaW5nOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm9vdENsYXNzZXMgPSBjeChjbGFzc2VzLmltYWdlLCB7XG4gICAgICAgICAgICBbY2xhc3Nlcy5ibHVyXTogbG9hZGluZyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPFRyYW5zZm9ybVdyYXBwZXI+XG4gICAgICAgICAgICAgIDxUcmFuc2Zvcm1Db21wb25lbnQ+XG4gICAgICAgICAgICAgICAgPGltZyBjbGFzc05hbWU9e3Jvb3RDbGFzc2VzfSBzcmM9e3NyY30gYWx0PXtwcm9wcy5hbHR9IC8+XG4gICAgICAgICAgICAgIDwvVHJhbnNmb3JtQ29tcG9uZW50PlxuICAgICAgICAgICAgPC9UcmFuc2Zvcm1XcmFwcGVyPlxuICAgICAgICAgICk7XG4gICAgICAgIH19XG4gICAgICA8L1Byb2dyZXNzaXZlSW1hZ2U+XG4gICAgICA8VHlwb2dyYXBoeSBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRpb259IHZhcmlhbnQ9XCJib2R5MlwiPlxuICAgICAgICB7cHJvcHMuYWx0fVxuICAgICAgPC9UeXBvZ3JhcGh5PlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/progressive-image.tsx\n");

/***/ }),

/***/ "./node_modules/react-zoom-pan-pinch/dist/index.es.js":
/*!************************************************************!*\
  !*** ./node_modules/react-zoom-pan-pinch/dist/index.es.js ***!
  \************************************************************/
/*! exports provided: TransformComponent, TransformWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransformComponent\", function() { return TransformComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransformWrapper\", function() { return TransformWrapper; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nvar initialState = {\r\n    wrapperComponent: null,\r\n    contentComponent: null,\r\n    previousScale: 1,\r\n    scale: 1,\r\n    positionX: 0,\r\n    positionY: 0,\r\n    options: {\r\n        disabled: false,\r\n        transformEnabled: true,\r\n        minPositionX: null,\r\n        maxPositionX: null,\r\n        minPositionY: null,\r\n        maxPositionY: null,\r\n        minScale: 1,\r\n        maxScale: 8,\r\n        limitToBounds: true,\r\n        limitToWrapper: false,\r\n        centerContent: true,\r\n        wrapperClass: \"\",\r\n        contentClass: \"\",\r\n    },\r\n    wheel: {\r\n        disabled: false,\r\n        step: 5,\r\n        wheelEnabled: true,\r\n        touchPadEnabled: true,\r\n        limitsOnWheel: false,\r\n    },\r\n    pan: {\r\n        disabled: false,\r\n        panAnimationType: \"linear\",\r\n        lockAxisX: false,\r\n        lockAxisY: false,\r\n        velocity: true,\r\n        velocityEqualToMove: true,\r\n        velocitySensitivity: 2,\r\n        velocityActiveScale: 1,\r\n        velocityMinSpeed: 1,\r\n        velocityBaseTime: 1600,\r\n        velocityAnimationType: \"easeOutQuart\",\r\n        padding: true,\r\n        paddingSize: 30,\r\n        panReturnAnimationTime: 400,\r\n        panReturnAnimationType: \"easeOut\",\r\n        disableOnTarget: [],\r\n    },\r\n    pinch: {\r\n        disabled: false,\r\n    },\r\n    zoomIn: {\r\n        disabled: false,\r\n        step: 20,\r\n        animation: true,\r\n        animationType: \"easeOut\",\r\n        animationTime: 200,\r\n    },\r\n    zoomOut: {\r\n        disabled: false,\r\n        step: 20,\r\n        animation: true,\r\n        animationType: \"easeOut\",\r\n        animationTime: 200,\r\n    },\r\n    doubleClick: {\r\n        disabled: false,\r\n        step: 20,\r\n        mode: \"zoomIn\",\r\n        animation: true,\r\n        animationType: \"easeOut\",\r\n        animationTime: 200,\r\n    },\r\n    reset: {\r\n        disabled: false,\r\n        animation: true,\r\n        animationType: \"easeOut\",\r\n        animationTime: 200,\r\n    },\r\n    scalePadding: {\r\n        disabled: false,\r\n        size: 0.2,\r\n        animationTime: 200,\r\n        animationType: \"easeOut\",\r\n    },\r\n};\n\n/**\r\n * Rounds number to given decimal\r\n * eg. roundNumber(2.34343, 1) => 2.3\r\n */\r\nvar roundNumber = function (num, decimal) {\r\n    return Number(num.toFixed(decimal));\r\n};\r\n/**\r\n * Checks if value is number, if not it returns default value\r\n * 1# eg. checkIsNumber(2, 30) => 2\r\n * 2# eg. checkIsNumber(null, 30) => 30\r\n */\r\nvar checkIsNumber = function (num, defaultValue) {\r\n    return typeof num === \"number\" ? num : defaultValue;\r\n};\r\n/**\r\n * Keeps value between given bounds, used for limiting view to given boundaries\r\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\r\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\r\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\r\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\r\n */\r\nvar boundLimiter = function (value, minBound, maxBound, isActive) {\r\n    if (!isActive)\r\n        return roundNumber(value, 2);\r\n    if (value < minBound)\r\n        return roundNumber(minBound, 2);\r\n    if (value > maxBound)\r\n        return roundNumber(maxBound, 2);\r\n    return roundNumber(value, 2);\r\n};\r\n/**\r\n * Calculate bounding area of zoomed/panned element\r\n */\r\nvar calculateBoundingArea = function (wrapperWidth, newContentWidth, diffWidth, wrapperHeight, newContentHeight, diffHeight, limitToWrapper) {\r\n    var scaleWidthFactor = wrapperWidth > newContentWidth\r\n        ? diffWidth * (limitToWrapper ? 1 : 0.5)\r\n        : 0;\r\n    var scaleHeightFactor = wrapperHeight > newContentHeight\r\n        ? diffHeight * (limitToWrapper ? 1 : 0.5)\r\n        : 0;\r\n    var minPositionX = wrapperWidth - newContentWidth - scaleWidthFactor;\r\n    var maxPositionX = scaleWidthFactor;\r\n    var minPositionY = wrapperHeight - newContentHeight - scaleHeightFactor;\r\n    var maxPositionY = scaleHeightFactor;\r\n    return { minPositionX: minPositionX, maxPositionX: maxPositionX, minPositionY: minPositionY, maxPositionY: maxPositionY };\r\n};\r\n/**\r\n * Returns distance between two points x,y\r\n */\r\nvar getDistance = function (firstPoint, secondPoint) {\r\n    return Math.sqrt(Math.pow(firstPoint.pageX - secondPoint.pageX, 2) +\r\n        Math.pow(firstPoint.pageY - secondPoint.pageY, 2));\r\n};\r\n/**\r\n * Delete undefined values from object keys\r\n * Used for deleting empty props\r\n */\r\nvar deleteUndefinedProps = function (value) {\r\n    var newObject = __assign({}, value);\r\n    Object.keys(newObject).forEach(function (key) { return newObject[key] === undefined && delete newObject[key]; });\r\n    return newObject;\r\n};\r\n/**\r\n * Fire callback if it's function\r\n */\r\nvar handleCallback = function (callback, props) {\r\n    if (callback && typeof callback === \"function\") {\r\n        callback(props);\r\n    }\r\n};\r\nvar handleWheelStop = function (previousEvent, event, stateProvider) {\r\n    var scale = stateProvider.scale, _a = stateProvider.options, maxScale = _a.maxScale, minScale = _a.minScale;\r\n    if (!previousEvent)\r\n        return false;\r\n    if (scale < maxScale || scale > minScale)\r\n        return true;\r\n    if (Math.sign(previousEvent.deltaY) !== Math.sign(event.deltaY))\r\n        return true;\r\n    if (previousEvent.deltaY > 0 && previousEvent.deltaY < event.deltaY)\r\n        return true;\r\n    if (previousEvent.deltaY < 0 && previousEvent.deltaY > event.deltaY)\r\n        return true;\r\n    if (Math.sign(previousEvent.deltaY) !== Math.sign(event.deltaY))\r\n        return true;\r\n    return false;\r\n};\r\nvar mergeProps = function (initialState, dynamicProps) {\r\n    return Object.keys(initialState).reduce(function (acc, curr) {\r\n        if (typeof dynamicProps[curr] === \"object\" && dynamicProps[curr] !== null) {\r\n            acc[curr] = __assign(__assign({}, initialState[curr]), dynamicProps[curr]);\r\n        }\r\n        else {\r\n            acc[curr] =\r\n                dynamicProps[curr] === undefined\r\n                    ? initialState[curr]\r\n                    : dynamicProps[curr];\r\n        }\r\n        return acc;\r\n    }, {});\r\n};\r\nfunction getWindowScaleY(wrapper) {\r\n    if (!wrapper)\r\n        return 0;\r\n    return window.innerHeight / wrapper.offsetHeight;\r\n}\r\nfunction getWindowScaleX(wrapper) {\r\n    if (!wrapper)\r\n        return 0;\r\n    return window.innerWidth / wrapper.offsetWidth;\r\n}\n\n/**\r\n * Functions should return denominator of the target value, which is the next animation step.\r\n * t is a value from 0 to 1, reflecting the percentage of animation status.\r\n */\r\nvar easeOut = function (t) {\r\n    return -Math.cos(t * Math.PI) / 2 + 0.5;\r\n};\r\n// linear\r\nvar linear = function (t) {\r\n    return t;\r\n};\r\n// accelerating from zero velocity\r\nvar easeInQuad = function (t) {\r\n    return t * t;\r\n};\r\n// decelerating to zero velocity\r\nvar easeOutQuad = function (t) {\r\n    return t * (2 - t);\r\n};\r\n// acceleration until halfway, then deceleration\r\nvar easeInOutQuad = function (t) {\r\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n};\r\n// accelerating from zero velocity\r\nvar easeInCubic = function (t) {\r\n    return t * t * t;\r\n};\r\n// decelerating to zero velocity\r\nvar easeOutCubic = function (t) {\r\n    return --t * t * t + 1;\r\n};\r\n// acceleration until halfway, then deceleration\r\nvar easeInOutCubic = function (t) {\r\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\r\n};\r\n// accelerating from zero velocity\r\nvar easeInQuart = function (t) {\r\n    return t * t * t * t;\r\n};\r\n// decelerating to zero velocity\r\nvar easeOutQuart = function (t) {\r\n    return 1 - --t * t * t * t;\r\n};\r\n// acceleration until halfway, then deceleration\r\nvar easeInOutQuart = function (t) {\r\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\r\n};\r\n// accelerating from zero velocity\r\nvar easeInQuint = function (t) {\r\n    return t * t * t * t * t;\r\n};\r\n// decelerating to zero velocity\r\nvar easeOutQuint = function (t) {\r\n    return 1 + --t * t * t * t * t;\r\n};\r\n// acceleration until halfway, then deceleration\r\nvar easeInOutQuint = function (t) {\r\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\r\n};\r\nvar availableAnimations = {\r\n    easeOut: easeOut,\r\n    linear: linear,\r\n    easeInQuad: easeInQuad,\r\n    easeOutQuad: easeOutQuad,\r\n    easeInOutQuad: easeInOutQuad,\r\n    easeInCubic: easeInCubic,\r\n    easeOutCubic: easeOutCubic,\r\n    easeInOutCubic: easeInOutCubic,\r\n    easeInQuart: easeInQuart,\r\n    easeOutQuart: easeOutQuart,\r\n    easeInOutQuart: easeInOutQuart,\r\n    easeInQuint: easeInQuint,\r\n    easeOutQuint: easeOutQuint,\r\n    easeInOutQuint: easeInOutQuint,\r\n};\n\nfunction handleDisableAnimation() {\r\n    if (!this.mounted)\r\n        return;\r\n    if (this.animation) {\r\n        cancelAnimationFrame(this.animation);\r\n    }\r\n    this.animate = false;\r\n    this.animation = false;\r\n    this.velocity = false;\r\n}\r\nfunction animate(animationName, animationTime, callback) {\r\n    var _this = this;\r\n    if (!this.mounted)\r\n        return;\r\n    var startTime = new Date().getTime();\r\n    var lastStep = 1;\r\n    // if another animation is active\r\n    handleDisableAnimation.call(this);\r\n    // new animation\r\n    this.animation = function () {\r\n        if (!_this.animation || !_this.mounted)\r\n            return;\r\n        var frameTime = new Date().getTime() - startTime;\r\n        var animationProgress = frameTime / animationTime;\r\n        var animationType = availableAnimations[animationName];\r\n        var step = animationType(animationProgress);\r\n        if (frameTime >= animationTime) {\r\n            callback(lastStep);\r\n            _this.animation = null;\r\n        }\r\n        else {\r\n            callback(step);\r\n            requestAnimationFrame(_this.animation);\r\n        }\r\n    };\r\n    requestAnimationFrame(this.animation);\r\n}\r\nfunction animateComponent(_a) {\r\n    var _this = this;\r\n    var targetState = _a.targetState, speed = _a.speed, type = _a.type;\r\n    var _b = this.stateProvider, scale = _b.scale, positionX = _b.positionX, positionY = _b.positionY;\r\n    var scaleDiff = targetState.scale - scale;\r\n    var positionXDiff = targetState.positionX - positionX;\r\n    var positionYDiff = targetState.positionY - positionY;\r\n    if (speed === 0) {\r\n        this.stateProvider.previousScale = this.stateProvider.scale;\r\n        this.stateProvider.scale = targetState.scale;\r\n        this.stateProvider.positionX = targetState.positionX;\r\n        this.stateProvider.positionY = targetState.positionY;\r\n        this.applyTransformation();\r\n    }\r\n    else {\r\n        // animation start timestamp\r\n        animate.call(this, type, speed, function (step) {\r\n            _this.stateProvider.previousScale = _this.stateProvider.scale;\r\n            _this.stateProvider.scale = scale + scaleDiff * step;\r\n            _this.stateProvider.positionX = positionX + positionXDiff * step;\r\n            _this.stateProvider.positionY = positionY + positionYDiff * step;\r\n            // apply animation changes\r\n            _this.applyTransformation();\r\n        });\r\n    }\r\n}\n\nfunction checkZoomBounds(zoom, minScale, maxScale, zoomPadding, enablePadding) {\r\n    var scalePadding = enablePadding ? zoomPadding : 0;\r\n    var minScaleWithPadding = minScale - scalePadding;\r\n    if (!isNaN(maxScale) && zoom >= maxScale)\r\n        return maxScale;\r\n    if (!isNaN(minScale) && zoom <= minScaleWithPadding)\r\n        return minScaleWithPadding;\r\n    return zoom;\r\n}\r\nfunction checkPositionBounds(positionX, positionY, bounds, limitToBounds, paddingValue, wrapperComponent) {\r\n    var minPositionX = bounds.minPositionX, minPositionY = bounds.minPositionY, maxPositionX = bounds.maxPositionX, maxPositionY = bounds.maxPositionY;\r\n    var paddingX = wrapperComponent\r\n        ? (paddingValue * wrapperComponent.offsetWidth) / 100\r\n        : 0;\r\n    var paddingY = wrapperComponent\r\n        ? (paddingValue * wrapperComponent.offsetHeight) / 100\r\n        : 0;\r\n    var x = boundLimiter(positionX, minPositionX - paddingX, maxPositionX + paddingX, limitToBounds);\r\n    var y = boundLimiter(positionY, minPositionY - paddingY, maxPositionY + paddingY, limitToBounds);\r\n    return { x: x, y: y };\r\n}\r\nfunction getDelta(event, customDelta) {\r\n    var deltaY = event ? (event.deltaY < 0 ? 1 : -1) : 0;\r\n    var delta = checkIsNumber(customDelta, deltaY);\r\n    return delta;\r\n}\r\nfunction wheelMousePosition(event, contentComponent, scale) {\r\n    var contentRect = contentComponent.getBoundingClientRect();\r\n    // mouse position x, y over wrapper component\r\n    var mouseX = (event.clientX - contentRect.left) / scale;\r\n    var mouseY = (event.clientY - contentRect.top) / scale;\r\n    if (isNaN(mouseX) || isNaN(mouseY))\r\n        console.error(\"No mouse or touch offset found\");\r\n    return {\r\n        mouseX: mouseX,\r\n        mouseY: mouseY,\r\n    };\r\n}\r\nfunction getComponentsSizes(wrapperComponent, contentComponent, newScale) {\r\n    var wrapperWidth = wrapperComponent.offsetWidth;\r\n    var wrapperHeight = wrapperComponent.offsetHeight;\r\n    var contentWidth = contentComponent.offsetWidth;\r\n    var contentHeight = contentComponent.offsetHeight;\r\n    var newContentWidth = contentWidth * newScale;\r\n    var newContentHeight = contentHeight * newScale;\r\n    var newDiffWidth = wrapperWidth - newContentWidth;\r\n    var newDiffHeight = wrapperHeight - newContentHeight;\r\n    return {\r\n        wrapperWidth: wrapperWidth,\r\n        wrapperHeight: wrapperHeight,\r\n        newContentWidth: newContentWidth,\r\n        newDiffWidth: newDiffWidth,\r\n        newContentHeight: newContentHeight,\r\n        newDiffHeight: newDiffHeight,\r\n    };\r\n}\r\nfunction handleCalculatePositions(mouseX, mouseY, newScale, bounds, limitToBounds) {\r\n    var _a = this.stateProvider, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY, transformEnabled = _a.options.transformEnabled;\r\n    var scaleDifference = newScale - scale;\r\n    if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\")\r\n        return console.error(\"Mouse X and Y position were not provided!\");\r\n    if (!transformEnabled)\r\n        return { newPositionX: positionX, newPositionY: positionY };\r\n    var calculatedPositionX = positionX - mouseX * scaleDifference;\r\n    var calculatedPositionY = positionY - mouseY * scaleDifference;\r\n    // do not limit to bounds when there is padding animation,\r\n    // it causes animation strange behaviour\r\n    var newPositions = checkPositionBounds(calculatedPositionX, calculatedPositionY, bounds, limitToBounds, 0, null);\r\n    return newPositions;\r\n}\n\nfunction getClientPosition(event) {\r\n    var touches = event.touches;\r\n    // Mobile points\r\n    if (touches && touches.length === 1) {\r\n        return { clientX: touches[0].clientX, clientY: touches[0].clientY };\r\n    }\r\n    // Desktop points\r\n    if (!touches) {\r\n        return { clientX: event.clientX, clientY: event.clientY };\r\n    }\r\n    return null;\r\n}\r\nfunction handlePanning(event) {\r\n    var _a = this.stateProvider, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY, _b = _a.options, limitToBounds = _b.limitToBounds, minScale = _b.minScale, _c = _a.pan, lockAxisX = _c.lockAxisX, lockAxisY = _c.lockAxisY, padding = _c.padding, paddingSize = _c.paddingSize, wrapperComponent = _a.wrapperComponent;\r\n    if (!this.startCoords)\r\n        return;\r\n    var _d = this.startCoords, x = _d.x, y = _d.y;\r\n    var positions = getClientPosition(event);\r\n    if (!positions)\r\n        return console.error(\"Cannot find mouse client positions\");\r\n    var clientX = positions.clientX, clientY = positions.clientY;\r\n    // Get Position\r\n    var mouseX = clientX - x;\r\n    var mouseY = clientY - y;\r\n    var newPositionX = lockAxisX ? positionX : mouseX;\r\n    var newPositionY = lockAxisY ? positionY : mouseY;\r\n    // padding\r\n    var paddingValue = padding && scale >= minScale ? paddingSize : 0;\r\n    // If position didn't change\r\n    if (newPositionX === positionX && newPositionY === positionY)\r\n        return;\r\n    var calculatedPosition = checkPositionBounds(newPositionX, newPositionY, this.bounds, limitToBounds, paddingValue, wrapperComponent);\r\n    // Save panned position\r\n    handlePaddingAnimation.call(this, calculatedPosition.x, calculatedPosition.y);\r\n}\r\nfunction handlePanningAnimation() {\r\n    var _a = this.stateProvider, scale = _a.scale, minScale = _a.options.minScale, _b = _a.pan, disabled = _b.disabled, padding = _b.padding, panReturnAnimationTime = _b.panReturnAnimationTime, panReturnAnimationType = _b.panReturnAnimationType;\r\n    var isDisabled = disabled || scale < minScale || !padding;\r\n    if (isDisabled)\r\n        return;\r\n    var targetState = handlePanToBounds.call(this);\r\n    animateComponent.call(this, {\r\n        targetState: targetState,\r\n        speed: panReturnAnimationTime,\r\n        type: panReturnAnimationType,\r\n    });\r\n}\r\nfunction handlePanToBounds() {\r\n    var _a = this.stateProvider, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale, _b = _a.options, disabled = _b.disabled, limitToBounds = _b.limitToBounds, limitToWrapper = _b.limitToWrapper;\r\n    var wrapperComponent = this.state.wrapperComponent;\r\n    if (disabled)\r\n        return;\r\n    var _c = this.bounds, maxPositionX = _c.maxPositionX, minPositionX = _c.minPositionX, maxPositionY = _c.maxPositionY, minPositionY = _c.minPositionY;\r\n    var xChanged = positionX > maxPositionX || positionX < minPositionX;\r\n    var yChanged = positionY > maxPositionY || positionY < minPositionY;\r\n    var mouseX = positionX > maxPositionX\r\n        ? wrapperComponent.offsetWidth\r\n        : this.stateProvider.minPositionX || 0;\r\n    var mouseY = positionY > maxPositionY\r\n        ? wrapperComponent.offsetHeight\r\n        : this.stateProvider.minPositionY || 0;\r\n    var mousePosX = mouseX;\r\n    var mousePosY = mouseY;\r\n    var _d = handleCalculatePositions.call(this, mousePosX, mousePosY, scale, this.bounds, limitToBounds || limitToWrapper), x = _d.x, y = _d.y;\r\n    return {\r\n        scale: scale,\r\n        positionX: xChanged ? x : positionX,\r\n        positionY: yChanged ? y : positionY,\r\n    };\r\n}\r\nfunction handlePaddingAnimation(positionX, positionY) {\r\n    var padding = this.stateProvider.pan.padding;\r\n    if (!padding)\r\n        return;\r\n    this.stateProvider.positionX = positionX;\r\n    this.stateProvider.positionY = positionY;\r\n    this.applyTransformation();\r\n}\n\nfunction handleCalculateZoom(delta, step, disablePadding, getTarget, isBtnFunction) {\r\n    var _a = this.stateProvider, scale = _a.scale, _b = _a.options, maxScale = _b.maxScale, minScale = _b.minScale, _c = _a.scalePadding, size = _c.size, disabled = _c.disabled, wrapperComponent = _a.wrapperComponent;\r\n    var targetScale = null;\r\n    if (isBtnFunction) {\r\n        var scaleFactor = window.innerWidth * 0.0001;\r\n        var zoomFactor = delta < 0 ? 30 : 20;\r\n        targetScale =\r\n            scale + (step - step * scaleFactor) * delta * (scale / zoomFactor);\r\n    }\r\n    else {\r\n        var wrapperToWindowScale = 2 - window.innerWidth / wrapperComponent.offsetWidth;\r\n        var scaleFactor = Math.max(0.2, Math.min(0.99, wrapperToWindowScale));\r\n        var zoomFactor = 20;\r\n        targetScale =\r\n            scale + step * delta * ((scale - scale * scaleFactor) / zoomFactor);\r\n    }\r\n    if (getTarget)\r\n        return targetScale;\r\n    var paddingEnabled = disablePadding ? false : !disabled;\r\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, paddingEnabled);\r\n    return newScale;\r\n}\r\nfunction handleCalculateBounds(newScale, limitToWrapper) {\r\n    var _a = this.stateProvider, wrapperComponent = _a.wrapperComponent, contentComponent = _a.contentComponent;\r\n    var _b = getComponentsSizes(wrapperComponent, contentComponent, newScale), wrapperWidth = _b.wrapperWidth, wrapperHeight = _b.wrapperHeight, newContentWidth = _b.newContentWidth, newDiffWidth = _b.newDiffWidth, newContentHeight = _b.newContentHeight, newDiffHeight = _b.newDiffHeight;\r\n    var bounds = calculateBoundingArea(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, limitToWrapper);\r\n    // Save bounds\r\n    this.bounds = bounds;\r\n    return bounds;\r\n}\r\n/**\r\n * Wheel zoom event\r\n */\r\nfunction handleWheelZoom(event) {\r\n    var _a = this.stateProvider, scale = _a.scale, contentComponent = _a.contentComponent, limitToBounds = _a.options.limitToBounds, _b = _a.scalePadding, size = _b.size, disabled = _b.disabled, _c = _a.wheel, step = _c.step, limitsOnWheel = _c.limitsOnWheel;\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n    var delta = getDelta(event, null);\r\n    var newScale = handleCalculateZoom.call(this, delta, step, !event.ctrlKey);\r\n    // if scale not change\r\n    if (scale === newScale)\r\n        return;\r\n    var bounds = handleCalculateBounds.call(this, newScale, !limitsOnWheel);\r\n    var _d = wheelMousePosition(event, contentComponent, scale), mouseX = _d.mouseX, mouseY = _d.mouseY;\r\n    var isLimitedToBounds = limitToBounds && (disabled || size === 0 || limitsOnWheel);\r\n    var _e = handleCalculatePositions.call(this, mouseX, mouseY, newScale, bounds, isLimitedToBounds), x = _e.x, y = _e.y;\r\n    this.bounds = bounds;\r\n    this.stateProvider.previousScale = scale;\r\n    this.stateProvider.scale = newScale;\r\n    this.stateProvider.positionX = x;\r\n    this.stateProvider.positionY = y;\r\n    this.applyTransformation();\r\n}\r\n/**\r\n * Zoom for animations\r\n */\r\nfunction handleZoomToPoint(isDisabled, scale, mouseX, mouseY, event) {\r\n    var _a = this.stateProvider, contentComponent = _a.contentComponent, _b = _a.options, disabled = _b.disabled, minScale = _b.minScale, maxScale = _b.maxScale, limitToBounds = _b.limitToBounds, limitToWrapper = _b.limitToWrapper;\r\n    if (disabled || isDisabled)\r\n        return;\r\n    var newScale = checkZoomBounds(roundNumber(scale, 2), minScale, maxScale, null, null);\r\n    var bounds = handleCalculateBounds.call(this, newScale, limitToWrapper);\r\n    var mousePosX = mouseX;\r\n    var mousePosY = mouseY;\r\n    // if event is present - use it's mouse position\r\n    if (event) {\r\n        var mousePosition = wheelMousePosition(event, contentComponent, scale);\r\n        mousePosX = mousePosition.mouseX;\r\n        mousePosY = mousePosition.mouseY;\r\n    }\r\n    var _c = handleCalculatePositions.call(this, mousePosX, mousePosY, newScale, bounds, limitToBounds), x = _c.x, y = _c.y;\r\n    return { scale: newScale, positionX: x, positionY: y };\r\n}\r\nfunction handlePaddingAnimation$1() {\r\n    var _a = this.stateProvider, scale = _a.scale, wrapperComponent = _a.wrapperComponent, _b = _a.options, minScale = _b.minScale, limitToBounds = _b.limitToBounds, _c = _a.scalePadding, disabled = _c.disabled, animationTime = _c.animationTime, animationType = _c.animationType;\r\n    var isDisabled = disabled || scale >= minScale;\r\n    if (scale >= 1 || limitToBounds) {\r\n        // fire fit to bounds animation\r\n        handlePanningAnimation.call(this);\r\n    }\r\n    if (isDisabled)\r\n        return;\r\n    var mouseX = wrapperComponent.offsetWidth / 2;\r\n    var mouseY = wrapperComponent.offsetHeight / 2;\r\n    var targetState = handleZoomToPoint.call(this, false, minScale, mouseX, mouseY, null);\r\n    animateComponent.call(this, {\r\n        targetState: targetState,\r\n        speed: animationTime,\r\n        type: animationType,\r\n    });\r\n}\r\n/**\r\n * Button zoom events\r\n */\r\nfunction handleDoubleClick(event) {\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n    var _a = this.stateProvider, contentComponent = _a.contentComponent, scale = _a.scale, _b = _a.doubleClick, disabled = _b.disabled, mode = _b.mode, step = _b.step, animationTime = _b.animationTime, animationType = _b.animationType;\r\n    if (mode === \"reset\") {\r\n        return resetTransformations.call(this, event, animationTime);\r\n    }\r\n    var delta = mode === \"zoomOut\" ? -1 : 1;\r\n    var newScale = handleCalculateZoom.call(this, delta, step, undefined, undefined, true);\r\n    var _c = wheelMousePosition(event, contentComponent, scale), mouseX = _c.mouseX, mouseY = _c.mouseY;\r\n    var targetState = handleZoomToPoint.call(this, disabled, newScale, mouseX, mouseY);\r\n    if (targetState.scale === scale)\r\n        return;\r\n    var targetScale = handleCalculateZoom.call(this, delta, step, true, undefined, true);\r\n    var time = getButtonAnimationTime(targetScale, newScale, animationTime);\r\n    animateComponent.call(this, {\r\n        targetState: targetState,\r\n        speed: time,\r\n        type: animationType,\r\n    });\r\n}\r\nfunction handleZoomControls(customDelta, customStep) {\r\n    var _a = this.stateProvider, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY, wrapperComponent = _a.wrapperComponent, zoomIn = _a.zoomIn, zoomOut = _a.zoomOut;\r\n    var wrapperWidth = wrapperComponent.offsetWidth;\r\n    var wrapperHeight = wrapperComponent.offsetHeight;\r\n    var mouseX = (wrapperWidth / 2 - positionX) / scale;\r\n    var mouseY = (wrapperHeight / 2 - positionY) / scale;\r\n    var newScale = handleCalculateZoom.call(this, customDelta, customStep, undefined, undefined, true);\r\n    var isZoomIn = newScale > scale;\r\n    var animationSpeed = isZoomIn\r\n        ? zoomIn.animationTime\r\n        : zoomOut.animationTime;\r\n    var animationType = isZoomIn ? zoomIn.animationType : zoomOut.animationType;\r\n    var isDisabled = isZoomIn ? zoomIn.disabled : zoomOut.disabled;\r\n    var targetState = handleZoomToPoint.call(this, isDisabled, newScale, mouseX, mouseY);\r\n    if (targetState.scale === scale)\r\n        return;\r\n    var targetScale = handleCalculateZoom.call(this, customDelta, customStep, true, undefined, true);\r\n    var time = getButtonAnimationTime(targetScale, newScale, animationSpeed);\r\n    animateComponent.call(this, {\r\n        targetState: targetState,\r\n        speed: time,\r\n        type: animationType,\r\n    });\r\n}\r\nfunction resetTransformations(animationSpeed) {\r\n    var _a = this.props.defaultValues, defaultScale = _a.defaultScale, defaultPositionX = _a.defaultPositionX, defaultPositionY = _a.defaultPositionY;\r\n    var _b = this.stateProvider, scale = _b.scale, positionX = _b.positionX, positionY = _b.positionY, reset = _b.reset, _c = _b.options, disabled = _c.disabled, limitToBounds = _c.limitToBounds, centerContent = _c.centerContent, limitToWrapper = _c.limitToWrapper;\r\n    if (disabled || reset.disabled)\r\n        return;\r\n    if (scale === defaultScale &&\r\n        positionX === defaultPositionX &&\r\n        positionY === defaultPositionY)\r\n        return;\r\n    var speed = typeof animationSpeed === \"number\" ? animationSpeed : reset.animationTime;\r\n    var targetScale = checkIsNumber(defaultScale, initialState.scale);\r\n    var newPositionX = checkIsNumber(defaultPositionX, initialState.positionX);\r\n    var newPositionY = checkIsNumber(defaultPositionY, initialState.positionY);\r\n    if ((limitToBounds && !limitToWrapper) || centerContent) {\r\n        var bounds = handleCalculateBounds.call(this, targetScale, limitToWrapper);\r\n        newPositionX = bounds.minPositionX;\r\n        newPositionY = bounds.minPositionY;\r\n    }\r\n    var targetState = {\r\n        scale: targetScale,\r\n        positionX: newPositionX,\r\n        positionY: newPositionY,\r\n    };\r\n    animateComponent.call(this, {\r\n        targetState: targetState,\r\n        speed: speed,\r\n        type: reset.animationType,\r\n    });\r\n}\r\nfunction getButtonAnimationTime(targetScale, newScale, time) {\r\n    return time * (newScale / targetScale);\r\n}\n\nfunction round(number, decimal) {\r\n    var roundNumber = Math.pow(10, decimal);\r\n    return Math.round(number * roundNumber) / roundNumber;\r\n}\r\nfunction getCurrentDistance(event) {\r\n    return getDistance(event.touches[0], event.touches[1]);\r\n}\r\nfunction checkIfInfinite(number) {\r\n    return number === Infinity || number === -Infinity;\r\n}\r\nfunction calculatePinchZoom(currentDistance, pinchStartDistance) {\r\n    var _a = this.stateProvider, _b = _a.options, minScale = _b.minScale, maxScale = _b.maxScale, _c = _a.scalePadding, size = _c.size, disabled = _c.disabled;\r\n    if (typeof pinchStartDistance !== \"number\" ||\r\n        typeof currentDistance !== \"number\")\r\n        return console.error(\"Pinch touches distance was not provided\");\r\n    if (currentDistance < 0)\r\n        return;\r\n    var touchProportion = currentDistance / pinchStartDistance;\r\n    var scaleDifference = touchProportion * this.pinchStartScale;\r\n    return checkZoomBounds(roundNumber(scaleDifference, 2), minScale, maxScale, size, !disabled);\r\n}\r\nfunction calculateMidpoint(event, scale, contentComponent) {\r\n    var contentRect = contentComponent.getBoundingClientRect();\r\n    var touches = event.touches;\r\n    var firstPointX = round(touches[0].clientX - contentRect.left, 5);\r\n    var firstPointY = round(touches[0].clientY - contentRect.top, 5);\r\n    var secondPointX = round(touches[1].clientX - contentRect.left, 5);\r\n    var secondPointY = round(touches[1].clientY - contentRect.top, 5);\r\n    return {\r\n        mouseX: (firstPointX + secondPointX) / 2 / scale,\r\n        mouseY: (firstPointY + secondPointY) / 2 / scale,\r\n    };\r\n}\r\nfunction handleZoomPinch(event) {\r\n    var _a = this.stateProvider, scale = _a.scale, _b = _a.options, limitToBounds = _b.limitToBounds, limitToWrapper = _b.limitToWrapper, _c = _a.scalePadding, disabled = _c.disabled, size = _c.size, limitsOnWheel = _a.wheel.limitsOnWheel, pinch = _a.pinch;\r\n    var contentComponent = this.state.contentComponent;\r\n    if (pinch.disabled || this.stateProvider.options.disabled)\r\n        return;\r\n    if (event.cancelable) {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n    }\r\n    // if one finger starts from outside of wrapper\r\n    if (this.pinchStartDistance === null)\r\n        return;\r\n    // Position transformation\r\n    var _d = calculateMidpoint(event, scale, contentComponent), mouseX = _d.mouseX, mouseY = _d.mouseY;\r\n    // if touches goes off of the wrapper element\r\n    if (checkIfInfinite(mouseX) || checkIfInfinite(mouseY))\r\n        return;\r\n    var currentDistance = getCurrentDistance(event);\r\n    var newScale = calculatePinchZoom.call(this, currentDistance, this.pinchStartDistance);\r\n    if (checkIfInfinite(newScale) || newScale === scale)\r\n        return;\r\n    // Get new element sizes to calculate bounds\r\n    var bounds = handleCalculateBounds.call(this, newScale, limitToWrapper);\r\n    // Calculate transformations\r\n    var isLimitedToBounds = limitToBounds && (disabled || size === 0 || limitsOnWheel);\r\n    var _e = handleCalculatePositions.call(this, mouseX, mouseY, newScale, bounds, isLimitedToBounds), x = _e.x, y = _e.y;\r\n    this.lastDistance = currentDistance;\r\n    this.stateProvider.positionX = x;\r\n    this.stateProvider.positionY = y;\r\n    this.stateProvider.scale = newScale;\r\n    this.stateProvider.previousScale = scale;\r\n    // update component transformation\r\n    this.applyTransformation();\r\n}\n\nvar throttleTime = 30;\r\nfunction velocityTimeSpeed(speed, animationTime) {\r\n    var velocityEqualToMove = this.stateProvider.pan.velocityEqualToMove;\r\n    if (velocityEqualToMove) {\r\n        return animationTime - animationTime / Math.max(1, speed);\r\n    }\r\n    return animationTime;\r\n}\r\nfunction handleEnableVelocity() {\r\n    this.setState({ startAnimation: false });\r\n}\r\nfunction handleFireVelocity() {\r\n    this.setState({ startAnimation: true });\r\n}\r\nfunction animateVelocity() {\r\n    var _this = this;\r\n    var _a = this.stateProvider, positionX = _a.positionX, positionY = _a.positionY, limitToBounds = _a.options.limitToBounds, _b = _a.pan, velocityBaseTime = _b.velocityBaseTime, lockAxisX = _b.lockAxisX, lockAxisY = _b.lockAxisY, velocityAnimationType = _b.velocityAnimationType, panReturnAnimationTime = _b.panReturnAnimationTime, panReturnAnimationType = _b.panReturnAnimationType, padding = _b.padding, paddingSize = _b.paddingSize, wrapperComponent = _a.wrapperComponent;\r\n    if (!this.mounted)\r\n        return;\r\n    if (!this.velocity || !this.bounds)\r\n        return handleDisableAnimation.call(this);\r\n    var _c = this.bounds, maxPositionX = _c.maxPositionX, minPositionX = _c.minPositionX, maxPositionY = _c.maxPositionY, minPositionY = _c.minPositionY;\r\n    var _d = this.velocity, velocityX = _d.velocityX, velocityY = _d.velocityY, velocity = _d.velocity;\r\n    var animationTime = velocityTimeSpeed.call(this, velocity, velocityBaseTime);\r\n    if (!animationTime) {\r\n        handlePanningAnimation.call(this);\r\n        return;\r\n    }\r\n    var targetX = velocityX;\r\n    var targetY = velocityY;\r\n    // pan return animation\r\n    var newAnimationTime = animationTime > panReturnAnimationTime\r\n        ? animationTime\r\n        : panReturnAnimationTime;\r\n    var paddingValue = padding ? paddingSize : 0;\r\n    var paddingX = wrapperComponent\r\n        ? (paddingValue * wrapperComponent.offsetWidth) / 100\r\n        : 0;\r\n    var paddingY = wrapperComponent\r\n        ? (paddingValue * wrapperComponent.offsetHeight) / 100\r\n        : 0;\r\n    var maxTargetX = maxPositionX + paddingX;\r\n    var minTargetX = minPositionX - paddingX;\r\n    var maxTargetY = maxPositionY + paddingY;\r\n    var minTargetY = minPositionY - paddingY;\r\n    var startPosition = checkPositionBounds(positionX, positionY, this.bounds, limitToBounds, paddingValue, wrapperComponent);\r\n    var startTime = new Date().getTime();\r\n    // animation start timestamp\r\n    animate.call(this, velocityAnimationType, newAnimationTime, function (step) {\r\n        var frameTime = new Date().getTime() - startTime;\r\n        var animationProgress = frameTime / panReturnAnimationTime;\r\n        var returnAnimation = availableAnimations[panReturnAnimationType];\r\n        var customReturnStep = returnAnimation(animationProgress);\r\n        if (frameTime > panReturnAnimationTime ||\r\n            customReturnStep > 1 ||\r\n            customReturnStep === Infinity ||\r\n            customReturnStep === -Infinity)\r\n            customReturnStep = 1;\r\n        var currentPositionX = getPosition(lockAxisX, targetX, step, customReturnStep, minPositionX, maxPositionX, limitToBounds, positionX, startPosition.x, minTargetX, maxTargetX);\r\n        var currentPositionY = getPosition(lockAxisY, targetY, step, customReturnStep, minPositionY, maxPositionY, limitToBounds, positionY, startPosition.y, minTargetY, maxTargetY);\r\n        if (positionX !== currentPositionX || positionY !== currentPositionY) {\r\n            // Save panned position\r\n            _this.stateProvider.positionX = currentPositionX;\r\n            _this.stateProvider.positionY = currentPositionY;\r\n            // apply animation changes\r\n            _this.applyTransformation();\r\n        }\r\n    });\r\n}\r\nfunction calculateVelocityStart(event) {\r\n    var _this = this;\r\n    var _a = this.stateProvider, scale = _a.scale, disabled = _a.options.disabled, _b = _a.pan, velocity = _b.velocity, velocitySensitivity = _b.velocitySensitivity, velocityActiveScale = _b.velocityActiveScale, velocityMinSpeed = _b.velocityMinSpeed, wrapperComponent = _a.wrapperComponent;\r\n    if (!velocity || velocityActiveScale >= scale || disabled)\r\n        return;\r\n    handleEnableVelocity.call(this);\r\n    var now = Date.now();\r\n    if (this.lastMousePosition) {\r\n        var position_1 = getClientPosition(event);\r\n        if (!position_1)\r\n            return console.error(\"No mouse or touch position detected\");\r\n        var clientX = position_1.clientX, clientY = position_1.clientY;\r\n        var distanceX = clientX - this.lastMousePosition.clientX;\r\n        var distanceY = clientY - this.lastMousePosition.clientY;\r\n        var interval = now - this.velocityTime;\r\n        var wrapperToWindowScaleX = 2 - wrapperComponent.offsetWidth / window.innerWidth;\r\n        var wrapperToWindowScaleY = 2 - wrapperComponent.offsetHeight / window.innerHeight;\r\n        var scaledX = 20 * Math.max(velocityMinSpeed, Math.min(2, wrapperToWindowScaleX));\r\n        var scaledY = 20 * Math.max(velocityMinSpeed, Math.min(2, wrapperToWindowScaleY));\r\n        var velocityX = (distanceX / interval) * velocitySensitivity * scale * scaledX;\r\n        var velocityY = (distanceY / interval) * velocitySensitivity * scale * scaledY;\r\n        var speed = distanceX * distanceX + distanceY * distanceY;\r\n        var velocity_1 = (Math.sqrt(speed) / interval) * velocitySensitivity;\r\n        if (this.velocity && velocity_1 < this.velocity.velocity && this.throttle)\r\n            return;\r\n        this.velocity = { velocityX: velocityX, velocityY: velocityY, velocity: velocity_1 };\r\n        // throttling\r\n        if (this.throttle)\r\n            clearTimeout(this.throttle);\r\n        this.throttle = setTimeout(function () {\r\n            if (_this.mounted)\r\n                _this.throttle = false;\r\n        }, throttleTime);\r\n    }\r\n    var position = getClientPosition(event);\r\n    this.lastMousePosition = position;\r\n    this.velocityTime = now;\r\n}\r\nfunction getPosition(isLocked, target, step, panReturnStep, minBound, maxBound, limitToBounds, offset, startPosition, minTarget, maxTarget) {\r\n    if (limitToBounds) {\r\n        if (startPosition > minBound && offset > maxBound) {\r\n            var newPosition = startPosition - (startPosition - maxBound) * panReturnStep;\r\n            if (newPosition > maxTarget)\r\n                return maxTarget;\r\n            if (newPosition < maxBound)\r\n                return maxBound;\r\n            return newPosition;\r\n        }\r\n        if (startPosition < minBound && offset < minBound) {\r\n            var newPosition = startPosition - (startPosition - minBound) * panReturnStep;\r\n            if (newPosition < minTarget)\r\n                return minTarget;\r\n            if (newPosition > minBound)\r\n                return minBound;\r\n            return newPosition;\r\n        }\r\n    }\r\n    if (isLocked)\r\n        return startPosition;\r\n    var offsetPosition = offset + target * step;\r\n    return boundLimiter(offsetPosition, minBound, maxBound, limitToBounds);\r\n}\n\n// We want to make event listeners non-passive, and to do so have to check\r\nfunction makePassiveEventOption(passive) {\r\n    return  passive;\r\n}\n\nvar propsList = [\r\n    \"previousScale\",\r\n    \"scale\",\r\n    \"positionX\",\r\n    \"positionY\",\r\n    \"defaultPositionX\",\r\n    \"defaultPositionY\",\r\n    \"defaultScale\",\r\n    \"onWheelStart\",\r\n    \"onWheel\",\r\n    \"onWheelStop\",\r\n    \"onPanningStart\",\r\n    \"onPanning\",\r\n    \"onPanningStop\",\r\n    \"onPinchingStart\",\r\n    \"onPinching\",\r\n    \"onPinchingStop\",\r\n    \"onZoomChange\",\r\n    \"options\",\r\n    \"wheel\",\r\n    \"scalePadding\",\r\n    \"pan\",\r\n    \"pinch\",\r\n    \"zoomIn\",\r\n    \"zoomOut\",\r\n    \"doubleClick\",\r\n    \"reset\",\r\n];\r\nvar getValidPropsFromObject = function (props) {\r\n    return Object.keys(props).reduce(function (acc, key) {\r\n        if (propsList.includes(key)) {\r\n            acc[key] = props[key];\r\n        }\r\n        return acc;\r\n    }, {});\r\n};\n\nvar Context = react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({});\r\nvar wheelStopEventTimer = null;\r\nvar wheelStopEventTime = 180;\r\nvar wheelAnimationTimer = null;\r\nvar wheelAnimationTime = 100;\r\nvar StateProvider = /** @class */ (function (_super) {\r\n    __extends(StateProvider, _super);\r\n    function StateProvider() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.mounted = true;\r\n        _this.state = {\r\n            wrapperComponent: undefined,\r\n            contentComponent: undefined,\r\n        };\r\n        _this.stateProvider = __assign(__assign(__assign(__assign({}, initialState), mergeProps(initialState, _this.props.dynamicValues)), _this.props.defaultValues), { previousScale: _this.props.dynamicValues.scale ||\r\n                _this.props.defaultValues.scale ||\r\n                initialState.scale });\r\n        _this.windowToWrapperScaleX = 0;\r\n        _this.windowToWrapperScaleY = 0;\r\n        // panning helpers\r\n        _this.startCoords = null;\r\n        _this.isDown = false;\r\n        // pinch helpers\r\n        _this.pinchStartDistance = null;\r\n        _this.lastDistance = null;\r\n        _this.pinchStartScale = null;\r\n        _this.distance = null;\r\n        _this.bounds = null;\r\n        // velocity helpers\r\n        _this.velocityTime = null;\r\n        _this.lastMousePosition = null;\r\n        _this.velocity = null;\r\n        _this.offsetX = null;\r\n        _this.offsetY = null;\r\n        _this.throttle = false;\r\n        // wheel helpers\r\n        _this.previousWheelEvent = null;\r\n        _this.lastScale = null;\r\n        // animations helpers\r\n        _this.animate = null;\r\n        _this.animation = null;\r\n        _this.maxBounds = null;\r\n        //////////\r\n        // Wheel\r\n        //////////\r\n        _this.handleWheel = function (event) {\r\n            var _a = _this.stateProvider, scale = _a.scale, _b = _a.wheel, disabled = _b.disabled, wheelEnabled = _b.wheelEnabled, touchPadEnabled = _b.touchPadEnabled;\r\n            var _c = _this.props, onWheelStart = _c.onWheelStart, onWheel = _c.onWheel, onWheelStop = _c.onWheelStop;\r\n            var _d = _this.state, wrapperComponent = _d.wrapperComponent, contentComponent = _d.contentComponent;\r\n            if (_this.isDown ||\r\n                disabled ||\r\n                _this.stateProvider.options.disabled ||\r\n                !wrapperComponent ||\r\n                !contentComponent)\r\n                return;\r\n            // ctrlKey detects if touchpad execute wheel or pinch gesture\r\n            if (!wheelEnabled && !event.ctrlKey)\r\n                return;\r\n            if (!touchPadEnabled && event.ctrlKey)\r\n                return;\r\n            // Wheel start event\r\n            if (!wheelStopEventTimer) {\r\n                _this.lastScale = scale;\r\n                handleDisableAnimation.call(_this);\r\n                handleCallback(onWheelStart, _this.getCallbackProps());\r\n            }\r\n            // Wheel event\r\n            handleWheelZoom.call(_this, event);\r\n            handleCallback(onWheel, _this.getCallbackProps());\r\n            _this.applyTransformation(null, null, null);\r\n            _this.previousWheelEvent = event;\r\n            // Wheel stop event\r\n            if (handleWheelStop(_this.previousWheelEvent, event, _this.stateProvider)) {\r\n                clearTimeout(wheelStopEventTimer);\r\n                wheelStopEventTimer = setTimeout(function () {\r\n                    if (!_this.mounted)\r\n                        return;\r\n                    handleCallback(onWheelStop, _this.getCallbackProps());\r\n                    wheelStopEventTimer = null;\r\n                }, wheelStopEventTime);\r\n            }\r\n            // cancel animation\r\n            _this.animate = false;\r\n            // fire animation\r\n            _this.lastScale = _this.stateProvider.scale;\r\n            clearTimeout(wheelAnimationTimer);\r\n            wheelAnimationTimer = setTimeout(function () {\r\n                if (!_this.mounted)\r\n                    return;\r\n                handlePaddingAnimation$1.call(_this, event);\r\n            }, wheelAnimationTime);\r\n        };\r\n        //////////\r\n        // Panning\r\n        //////////\r\n        _this.checkPanningTarget = function (event) {\r\n            var disableOnTarget = _this.stateProvider.pan.disableOnTarget;\r\n            return (disableOnTarget\r\n                .map(function (tag) { return tag.toUpperCase(); })\r\n                .includes(event.target.tagName) ||\r\n                disableOnTarget.find(function (element) {\r\n                    return event.target.classList.value.includes(element);\r\n                }));\r\n        };\r\n        _this.checkIsPanningActive = function (event) {\r\n            var disabled = _this.stateProvider.pan.disabled;\r\n            var _a = _this.state, wrapperComponent = _a.wrapperComponent, contentComponent = _a.contentComponent;\r\n            return (!_this.isDown ||\r\n                disabled ||\r\n                _this.stateProvider.options.disabled ||\r\n                (event.touches &&\r\n                    (event.touches.length !== 1 ||\r\n                        Math.abs(_this.startCoords.x - event.touches[0].clientX) < 1 ||\r\n                        Math.abs(_this.startCoords.y - event.touches[0].clientY) < 1)) ||\r\n                !wrapperComponent ||\r\n                !contentComponent);\r\n        };\r\n        _this.handleSetUpPanning = function (x, y) {\r\n            var _a = _this.stateProvider, positionX = _a.positionX, positionY = _a.positionY;\r\n            _this.isDown = true;\r\n            _this.startCoords = { x: x - positionX, y: y - positionY };\r\n            handleCallback(_this.props.onPanningStart, _this.getCallbackProps());\r\n        };\r\n        _this.handleStartPanning = function (event) {\r\n            var _a = _this.stateProvider, wrapperComponent = _a.wrapperComponent, scale = _a.scale, _b = _a.options, minScale = _b.minScale, maxScale = _b.maxScale, limitToWrapper = _b.limitToWrapper, disabled = _a.pan.disabled;\r\n            var target = event.target, touches = event.touches;\r\n            if (disabled ||\r\n                _this.stateProvider.options.disabled ||\r\n                (wrapperComponent && !wrapperComponent.contains(target)) ||\r\n                _this.checkPanningTarget(event) ||\r\n                scale < minScale ||\r\n                scale > maxScale)\r\n                return;\r\n            handleDisableAnimation.call(_this);\r\n            _this.bounds = handleCalculateBounds.call(_this, scale, limitToWrapper);\r\n            // Mobile points\r\n            if (touches && touches.length === 1) {\r\n                _this.handleSetUpPanning(touches[0].clientX, touches[0].clientY);\r\n            }\r\n            // Desktop points\r\n            if (!touches) {\r\n                _this.handleSetUpPanning(event.clientX, event.clientY);\r\n            }\r\n        };\r\n        _this.handlePanning = function (event) {\r\n            if (_this.isDown)\r\n                event.preventDefault();\r\n            if (_this.checkIsPanningActive(event))\r\n                return;\r\n            event.stopPropagation();\r\n            calculateVelocityStart.call(_this, event);\r\n            handlePanning.call(_this, event);\r\n            handleCallback(_this.props.onPanning, _this.getCallbackProps());\r\n        };\r\n        _this.handleStopPanning = function () {\r\n            if (_this.isDown) {\r\n                _this.isDown = false;\r\n                _this.animate = false;\r\n                _this.animation = false;\r\n                handleFireVelocity.call(_this);\r\n                handleCallback(_this.props.onPanningStop, _this.getCallbackProps());\r\n                var _a = _this.stateProvider, velocity = _a.pan.velocity, scale = _a.scale;\r\n                // start velocity animation\r\n                if (_this.velocity && velocity && scale > 1) {\r\n                    animateVelocity.call(_this);\r\n                }\r\n                else {\r\n                    // fire fit to bounds animation\r\n                    handlePanningAnimation.call(_this);\r\n                }\r\n            }\r\n        };\r\n        //////////\r\n        // Pinch\r\n        //////////\r\n        _this.handlePinchStart = function (event) {\r\n            var scale = _this.stateProvider.scale;\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            handleDisableAnimation.call(_this);\r\n            var distance = getDistance(event.touches[0], event.touches[1]);\r\n            _this.pinchStartDistance = distance;\r\n            _this.lastDistance = distance;\r\n            _this.pinchStartScale = scale;\r\n            _this.isDown = false;\r\n            handleCallback(_this.props.onPinchingStart, _this.getCallbackProps());\r\n        };\r\n        _this.handlePinch = function (event) {\r\n            _this.isDown = false;\r\n            handleZoomPinch.call(_this, event);\r\n            handleCallback(_this.props.onPinching, _this.getCallbackProps());\r\n        };\r\n        _this.handlePinchStop = function () {\r\n            if (typeof _this.pinchStartScale === \"number\") {\r\n                _this.isDown = false;\r\n                _this.velocity = null;\r\n                _this.lastDistance = null;\r\n                _this.pinchStartScale = null;\r\n                _this.pinchStartDistance = null;\r\n                handlePaddingAnimation$1.call(_this);\r\n                handleCallback(_this.props.onPinchingStop, _this.getCallbackProps());\r\n            }\r\n        };\r\n        //////////\r\n        // Touch Events\r\n        //////////\r\n        _this.handleTouchStart = function (event) {\r\n            var _a = _this.stateProvider, wrapperComponent = _a.wrapperComponent, contentComponent = _a.contentComponent, scale = _a.scale, _b = _a.options, disabled = _b.disabled, minScale = _b.minScale;\r\n            var touches = event.touches;\r\n            if (disabled || !wrapperComponent || !contentComponent || scale < minScale)\r\n                return;\r\n            handleDisableAnimation.call(_this);\r\n            if (touches && touches.length === 1)\r\n                return _this.handleStartPanning(event);\r\n            if (touches && touches.length === 2)\r\n                return _this.handlePinchStart(event);\r\n        };\r\n        _this.handleTouch = function (event) {\r\n            var _a = _this.stateProvider, pan = _a.pan, pinch = _a.pinch, options = _a.options;\r\n            if (options.disabled)\r\n                return;\r\n            if (!pan.disabled && event.touches.length === 1)\r\n                return _this.handlePanning(event);\r\n            if (!pinch.disabled && event.touches.length === 2)\r\n                return _this.handlePinch(event);\r\n        };\r\n        _this.handleTouchStop = function () {\r\n            _this.handleStopPanning();\r\n            _this.handlePinchStop();\r\n        };\r\n        //////////\r\n        // Controls\r\n        //////////\r\n        _this.zoomIn = function (event) {\r\n            var _a = _this.stateProvider, _b = _a.zoomIn, disabled = _b.disabled, step = _b.step, options = _a.options;\r\n            var _c = _this.state, wrapperComponent = _c.wrapperComponent, contentComponent = _c.contentComponent;\r\n            if (!event)\r\n                throw Error(\"Zoom in function requires event prop\");\r\n            if (disabled || options.disabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            handleZoomControls.call(_this, 1, step);\r\n        };\r\n        _this.zoomOut = function (event) {\r\n            var _a = _this.stateProvider, _b = _a.zoomOut, disabled = _b.disabled, step = _b.step, options = _a.options;\r\n            var _c = _this.state, wrapperComponent = _c.wrapperComponent, contentComponent = _c.contentComponent;\r\n            if (!event)\r\n                throw Error(\"Zoom out function requires event prop\");\r\n            if (disabled || options.disabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            handleZoomControls.call(_this, -1, step);\r\n        };\r\n        _this.handleDbClick = function (event) {\r\n            var _a = _this.stateProvider, options = _a.options, _b = _a.doubleClick, disabled = _b.disabled, step = _b.step;\r\n            var _c = _this.state, wrapperComponent = _c.wrapperComponent, contentComponent = _c.contentComponent;\r\n            if (!event)\r\n                throw Error(\"Double click function requires event prop\");\r\n            if (disabled || options.disabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            handleDoubleClick.call(_this, event, 1, step);\r\n        };\r\n        _this.setScale = function (newScale, speed, type) {\r\n            if (speed === void 0) { speed = 200; }\r\n            if (type === void 0) { type = \"easeOut\"; }\r\n            var _a = _this.stateProvider, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale, disabled = _a.options.disabled;\r\n            var _b = _this.state, wrapperComponent = _b.wrapperComponent, contentComponent = _b.contentComponent;\r\n            if (disabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            var targetState = {\r\n                positionX: positionX,\r\n                positionY: positionY,\r\n                scale: isNaN(newScale) ? scale : newScale,\r\n            };\r\n            animateComponent.call(_this, {\r\n                targetState: targetState,\r\n                speed: speed,\r\n                type: type,\r\n            });\r\n        };\r\n        _this.setPositionX = function (newPosX, speed, type) {\r\n            if (speed === void 0) { speed = 200; }\r\n            if (type === void 0) { type = \"easeOut\"; }\r\n            var _a = _this.stateProvider, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale, _b = _a.options, disabled = _b.disabled, transformEnabled = _b.transformEnabled;\r\n            var _c = _this.state, wrapperComponent = _c.wrapperComponent, contentComponent = _c.contentComponent;\r\n            if (disabled || !transformEnabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            var targetState = {\r\n                positionX: isNaN(newPosX) ? positionX : newPosX,\r\n                positionY: positionY,\r\n                scale: scale,\r\n            };\r\n            animateComponent.call(_this, {\r\n                targetState: targetState,\r\n                speed: speed,\r\n                type: type,\r\n            });\r\n        };\r\n        _this.setPositionY = function (newPosY, speed, type) {\r\n            if (speed === void 0) { speed = 200; }\r\n            if (type === void 0) { type = \"easeOut\"; }\r\n            var _a = _this.stateProvider, positionX = _a.positionX, scale = _a.scale, positionY = _a.positionY, _b = _a.options, disabled = _b.disabled, transformEnabled = _b.transformEnabled;\r\n            var _c = _this.state, wrapperComponent = _c.wrapperComponent, contentComponent = _c.contentComponent;\r\n            if (disabled || !transformEnabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            var targetState = {\r\n                positionX: positionX,\r\n                positionY: isNaN(newPosY) ? positionY : newPosY,\r\n                scale: scale,\r\n            };\r\n            animateComponent.call(_this, {\r\n                targetState: targetState,\r\n                speed: speed,\r\n                type: type,\r\n            });\r\n        };\r\n        _this.setTransform = function (newPosX, newPosY, newScale, speed, type) {\r\n            if (speed === void 0) { speed = 200; }\r\n            if (type === void 0) { type = \"easeOut\"; }\r\n            var _a = _this.stateProvider, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale, _b = _a.options, disabled = _b.disabled, transformEnabled = _b.transformEnabled;\r\n            var _c = _this.state, wrapperComponent = _c.wrapperComponent, contentComponent = _c.contentComponent;\r\n            if (disabled || !transformEnabled || !wrapperComponent || !contentComponent)\r\n                return;\r\n            var targetState = {\r\n                positionX: isNaN(newPosX) ? positionX : newPosX,\r\n                positionY: isNaN(newPosY) ? positionY : newPosY,\r\n                scale: isNaN(newScale) ? scale : newScale,\r\n            };\r\n            animateComponent.call(_this, {\r\n                targetState: targetState,\r\n                speed: speed,\r\n                type: type,\r\n            });\r\n        };\r\n        _this.resetTransform = function () {\r\n            var _a = _this.stateProvider.options, disabled = _a.disabled, transformEnabled = _a.transformEnabled;\r\n            if (disabled || !transformEnabled)\r\n                return;\r\n            resetTransformations.call(_this);\r\n        };\r\n        _this.setDefaultState = function () {\r\n            _this.animation = null;\r\n            _this.stateProvider = __assign(__assign(__assign({}, _this.stateProvider), { scale: initialState.scale, positionX: initialState.positionX, positionY: initialState.positionY }), _this.props.defaultValues);\r\n            _this.forceUpdate();\r\n        };\r\n        //////////\r\n        // Setters\r\n        //////////\r\n        _this.setWrapperComponent = function (wrapperComponent) {\r\n            _this.setState({ wrapperComponent: wrapperComponent });\r\n        };\r\n        _this.setContentComponent = function (contentComponent) {\r\n            _this.setState({ contentComponent: contentComponent }, function () {\r\n                var _a = _this.stateProvider, wrapperComponent = _a.wrapperComponent, _b = _a.options, centerContent = _b.centerContent, limitToBounds = _b.limitToBounds, limitToWrapper = _b.limitToWrapper, scale = _a.scale;\r\n                var _c = _this.props.defaultValues, positionX = _c.positionX, positionY = _c.positionY;\r\n                if ((limitToBounds && !limitToWrapper) ||\r\n                    (centerContent && !positionX && !positionY)) {\r\n                    var transform = \"translate(25%, 25%) scale(\" + scale + \")\";\r\n                    contentComponent.style.transform = transform;\r\n                    contentComponent.style.WebkitTransform = transform;\r\n                    // force update to inject state to the context\r\n                    _this.forceUpdate();\r\n                    var startTime_1 = new Date().getTime();\r\n                    var maxTimeWait_1 = 2000;\r\n                    var interval_1 = setInterval(function () {\r\n                        if (wrapperComponent.offsetWidth) {\r\n                            var bounds = handleCalculateBounds.call(_this, scale, false);\r\n                            _this.stateProvider.positionX = bounds.minPositionX;\r\n                            _this.stateProvider.positionY = bounds.minPositionY;\r\n                            _this.applyTransformation(null, null, null);\r\n                            clearInterval(interval_1);\r\n                            interval_1 = null;\r\n                        }\r\n                        else if (new Date().getTime() - startTime_1 > maxTimeWait_1) {\r\n                            clearInterval(interval_1);\r\n                            interval_1 = null;\r\n                        }\r\n                    }, 20);\r\n                }\r\n                else {\r\n                    _this.applyTransformation(null, null, null);\r\n                }\r\n            });\r\n        };\r\n        _this.applyTransformation = function (newScale, posX, posY) {\r\n            if (!_this.mounted)\r\n                return;\r\n            var contentComponent = _this.state.contentComponent;\r\n            var onZoomChange = _this.props.onZoomChange;\r\n            var _a = _this.stateProvider, previousScale = _a.previousScale, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\r\n            if (!contentComponent)\r\n                return console.error(\"There is no content component\");\r\n            var transform = \"translate(\" + (posX || positionX) + \"px, \" + (posY ||\r\n                positionY) + \"px) scale(\" + (newScale || scale) + \")\";\r\n            contentComponent.style.transform = transform;\r\n            contentComponent.style.WebkitTransform = transform;\r\n            // force update to inject state to the context\r\n            _this.forceUpdate();\r\n            if (onZoomChange && previousScale !== scale) {\r\n                handleCallback(onZoomChange, _this.getCallbackProps());\r\n            }\r\n        };\r\n        //////////\r\n        // Props\r\n        //////////\r\n        _this.getCallbackProps = function () { return getValidPropsFromObject(_this.stateProvider); };\r\n        return _this;\r\n    }\r\n    StateProvider.prototype.componentDidMount = function () {\r\n        var passiveOption = makePassiveEventOption(false);\r\n        // Panning on window to allow panning when mouse is out of wrapper\r\n        window.addEventListener(\"mousedown\", this.handleStartPanning, passiveOption);\r\n        window.addEventListener(\"mousemove\", this.handlePanning, passiveOption);\r\n        window.addEventListener(\"mouseup\", this.handleStopPanning, passiveOption);\r\n    };\r\n    StateProvider.prototype.componentWillUnmount = function () {\r\n        var passiveOption = makePassiveEventOption(false);\r\n        window.removeEventListener(\"mousedown\", this.handleStartPanning, passiveOption);\r\n        window.removeEventListener(\"mousemove\", this.handlePanning, passiveOption);\r\n        window.removeEventListener(\"mouseup\", this.handleStopPanning, passiveOption);\r\n        handleDisableAnimation.call(this);\r\n    };\r\n    StateProvider.prototype.componentDidUpdate = function (oldProps, oldState) {\r\n        var _a = this.state, wrapperComponent = _a.wrapperComponent, contentComponent = _a.contentComponent;\r\n        var dynamicValues = this.props.dynamicValues;\r\n        if (!oldState.contentComponent && contentComponent) {\r\n            this.stateProvider.contentComponent = contentComponent;\r\n        }\r\n        if (!oldState.wrapperComponent &&\r\n            wrapperComponent &&\r\n            wrapperComponent !== undefined) {\r\n            this.stateProvider.wrapperComponent = wrapperComponent;\r\n            this.windowToWrapperScaleX = getWindowScaleX(wrapperComponent);\r\n            this.windowToWrapperScaleY = getWindowScaleY(wrapperComponent);\r\n            // Zooming events on wrapper\r\n            var passiveOption = makePassiveEventOption(false);\r\n            wrapperComponent.addEventListener(\"wheel\", this.handleWheel, passiveOption);\r\n            wrapperComponent.addEventListener(\"dblclick\", this.handleDbClick, passiveOption);\r\n            wrapperComponent.addEventListener(\"touchstart\", this.handleTouchStart, passiveOption);\r\n            wrapperComponent.addEventListener(\"touchmove\", this.handleTouch, passiveOption);\r\n            wrapperComponent.addEventListener(\"touchend\", this.handleTouchStop, passiveOption);\r\n        }\r\n        // set bound for animations\r\n        if ((wrapperComponent && contentComponent) ||\r\n            oldProps.dynamicValues !== dynamicValues) {\r\n            this.maxBounds = handleCalculateBounds.call(this, this.stateProvider.scale, this.stateProvider.options.limitToWrapper);\r\n        }\r\n        // must be at the end of the update function, updates\r\n        if (oldProps.dynamicValues && oldProps.dynamicValues !== dynamicValues) {\r\n            this.animation = null;\r\n            this.stateProvider = __assign(__assign({}, this.stateProvider), mergeProps(this.stateProvider, dynamicValues));\r\n            this.applyTransformation(null, null, null);\r\n        }\r\n    };\r\n    StateProvider.prototype.render = function () {\r\n        var _a = this.state, wrapperComponent = _a.wrapperComponent, contentComponent = _a.contentComponent;\r\n        /**\r\n         * Context provider value\r\n         */\r\n        var value = {\r\n            loaded: Boolean(wrapperComponent && contentComponent),\r\n            state: this.getCallbackProps(),\r\n            dispatch: {\r\n                setScale: this.setScale,\r\n                setPositionX: this.setPositionX,\r\n                setPositionY: this.setPositionY,\r\n                zoomIn: this.zoomIn,\r\n                zoomOut: this.zoomOut,\r\n                setTransform: this.setTransform,\r\n                resetTransform: this.resetTransform,\r\n                setDefaultState: this.setDefaultState,\r\n            },\r\n            nodes: {\r\n                setWrapperComponent: this.setWrapperComponent,\r\n                setContentComponent: this.setContentComponent,\r\n            },\r\n        };\r\n        var children = this.props.children;\r\n        var content = typeof children === \"function\"\r\n            ? children(__assign(__assign({}, value.state), value.dispatch))\r\n            : children;\r\n        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Context.Provider, { value: value }, content);\r\n    };\r\n    return StateProvider;\r\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]));\n\nvar TransformWrapper = function (_a) {\r\n    var children = _a.children, defaultPositionX = _a.defaultPositionX, defaultPositionY = _a.defaultPositionY, defaultScale = _a.defaultScale, onWheelStart = _a.onWheelStart, onWheel = _a.onWheel, onWheelStop = _a.onWheelStop, onPanningStart = _a.onPanningStart, onPanning = _a.onPanning, onPanningStop = _a.onPanningStop, onPinchingStart = _a.onPinchingStart, onPinching = _a.onPinching, onPinchingStop = _a.onPinchingStop, onZoomChange = _a.onZoomChange, rest = __rest(_a, [\"children\", \"defaultPositionX\", \"defaultPositionY\", \"defaultScale\", \"onWheelStart\", \"onWheel\", \"onWheelStop\", \"onPanningStart\", \"onPanning\", \"onPanningStop\", \"onPinchingStart\", \"onPinching\", \"onPinchingStop\", \"onZoomChange\"]);\r\n    var props = __assign({}, rest);\r\n    if (props.options && props.options.limitToWrapper) {\r\n        props.options.limitToBounds = true;\r\n    }\r\n    return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(StateProvider, { defaultValues: deleteUndefinedProps({\r\n            positionX: defaultPositionX,\r\n            positionY: defaultPositionY,\r\n            scale: defaultScale,\r\n        }), dynamicValues: deleteUndefinedProps(getValidPropsFromObject(props)), onWheelStart: onWheelStart, onWheel: onWheel, onWheelStop: onWheelStop, onPanningStart: onPanningStart, onPanning: onPanning, onPanningStop: onPanningStop, onPinchingStart: onPinchingStart, onPinching: onPinching, onPinchingStop: onPinchingStop, onZoomChange: onZoomChange }, children));\r\n};\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".TransformComponent-module_container__3NwNd {\\n  position: relative;\\n  width: fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n.TransformComponent-module_content__TZU5O {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: fit-content;\\n  height: fit-content;\\n  margin: 0;\\n  padding: 0;\\n  transform-origin: 0% 0%;\\n}\\n.TransformComponent-module_content__TZU5O img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\"container\":\"TransformComponent-module_container__3NwNd\",\"content\":\"TransformComponent-module_content__TZU5O\"};\nstyleInject(css);\n\nvar TransformComponent = /** @class */ (function (_super) {\r\n    __extends(TransformComponent, _super);\r\n    function TransformComponent() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.wrapperRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef();\r\n        _this.contentRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef();\r\n        return _this;\r\n    }\r\n    TransformComponent.prototype.componentDidMount = function () {\r\n        var nodes = this.context.nodes;\r\n        nodes.setWrapperComponent(this.wrapperRef.current);\r\n        nodes.setContentComponent(this.contentRef.current);\r\n    };\r\n    TransformComponent.prototype.render = function () {\r\n        var children = this.props.children;\r\n        var _a = this.context.state, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale, _b = _a.options, wrapperClass = _b.wrapperClass, contentClass = _b.contentClass;\r\n        var style = {\r\n            WebkitTransform: \"translate(\" + positionX + \"px, \" + positionY + \"px) scale(\" + scale + \")\",\r\n            transform: \"translate(\" + positionX + \"px, \" + positionY + \"px) scale(\" + scale + \")\",\r\n        };\r\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { ref: this.wrapperRef, className: \"react-transform-component \" + styles.container + \" \" + wrapperClass },\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { ref: this.contentRef, className: \"react-transform-element \" + styles.content + \" \" + contentClass, style: style }, children)));\r\n    };\r\n    return TransformComponent;\r\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component));\r\nTransformComponent.contextType = Context;\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtem9vbS1wYW4tcGluY2gvZGlzdC9pbmRleC5lcy5qcz8yMWE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUM7O0FBRXpDO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ25GLHlCQUF5Qix1REFBdUQ7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsbURBQW1ELDhEQUE4RCxFQUFFO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUEsY0FBYyw0Q0FBSyxpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usb0dBQW9HO0FBQ3hLO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hELGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QixrR0FBa0c7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQXFEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsZUFBZSw0Q0FBSyxrQ0FBa0MsZUFBZTtBQUNyRTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLCtDQUFTOztBQUVYO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBSywrQkFBK0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUywwVkFBMFY7QUFDblc7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxRQUFROztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsdUJBQXVCLHVCQUF1Qix3QkFBd0IscUJBQXFCLGdDQUFnQywrQ0FBK0MsMENBQTBDLGdEQUFnRCx3Q0FBd0MsbURBQW1ELGNBQWMsZUFBZSxHQUFHLDZDQUE2QyxrQkFBa0Isb0JBQW9CLHVCQUF1Qix3QkFBd0IsY0FBYyxlQUFlLDRCQUE0QixHQUFHLGlEQUFpRCx5QkFBeUIsR0FBRztBQUNsc0IsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRDQUFLO0FBQ2hDLDJCQUEyQiw0Q0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFLLHVCQUF1Qix3R0FBd0c7QUFDcEosWUFBWSw0Q0FBSyx1QkFBdUIsa0hBQWtIO0FBQzFKO0FBQ0E7QUFDQSxDQUFDLENBQUMsNENBQUs7QUFDUDs7QUFFZ0Q7QUFDaEQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3Qtem9vbS1wYW4tcGluY2gvZGlzdC9pbmRleC5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cblxudmFyIGluaXRpYWxTdGF0ZSA9IHtcclxuICAgIHdyYXBwZXJDb21wb25lbnQ6IG51bGwsXHJcbiAgICBjb250ZW50Q29tcG9uZW50OiBudWxsLFxyXG4gICAgcHJldmlvdXNTY2FsZTogMSxcclxuICAgIHNjYWxlOiAxLFxyXG4gICAgcG9zaXRpb25YOiAwLFxyXG4gICAgcG9zaXRpb25ZOiAwLFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2Zvcm1FbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIG1pblBvc2l0aW9uWDogbnVsbCxcclxuICAgICAgICBtYXhQb3NpdGlvblg6IG51bGwsXHJcbiAgICAgICAgbWluUG9zaXRpb25ZOiBudWxsLFxyXG4gICAgICAgIG1heFBvc2l0aW9uWTogbnVsbCxcclxuICAgICAgICBtaW5TY2FsZTogMSxcclxuICAgICAgICBtYXhTY2FsZTogOCxcclxuICAgICAgICBsaW1pdFRvQm91bmRzOiB0cnVlLFxyXG4gICAgICAgIGxpbWl0VG9XcmFwcGVyOiBmYWxzZSxcclxuICAgICAgICBjZW50ZXJDb250ZW50OiB0cnVlLFxyXG4gICAgICAgIHdyYXBwZXJDbGFzczogXCJcIixcclxuICAgICAgICBjb250ZW50Q2xhc3M6IFwiXCIsXHJcbiAgICB9LFxyXG4gICAgd2hlZWw6IHtcclxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgc3RlcDogNSxcclxuICAgICAgICB3aGVlbEVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgdG91Y2hQYWRFbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIGxpbWl0c09uV2hlZWw6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIHBhbjoge1xyXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICBwYW5BbmltYXRpb25UeXBlOiBcImxpbmVhclwiLFxyXG4gICAgICAgIGxvY2tBeGlzWDogZmFsc2UsXHJcbiAgICAgICAgbG9ja0F4aXNZOiBmYWxzZSxcclxuICAgICAgICB2ZWxvY2l0eTogdHJ1ZSxcclxuICAgICAgICB2ZWxvY2l0eUVxdWFsVG9Nb3ZlOiB0cnVlLFxyXG4gICAgICAgIHZlbG9jaXR5U2Vuc2l0aXZpdHk6IDIsXHJcbiAgICAgICAgdmVsb2NpdHlBY3RpdmVTY2FsZTogMSxcclxuICAgICAgICB2ZWxvY2l0eU1pblNwZWVkOiAxLFxyXG4gICAgICAgIHZlbG9jaXR5QmFzZVRpbWU6IDE2MDAsXHJcbiAgICAgICAgdmVsb2NpdHlBbmltYXRpb25UeXBlOiBcImVhc2VPdXRRdWFydFwiLFxyXG4gICAgICAgIHBhZGRpbmc6IHRydWUsXHJcbiAgICAgICAgcGFkZGluZ1NpemU6IDMwLFxyXG4gICAgICAgIHBhblJldHVybkFuaW1hdGlvblRpbWU6IDQwMCxcclxuICAgICAgICBwYW5SZXR1cm5BbmltYXRpb25UeXBlOiBcImVhc2VPdXRcIixcclxuICAgICAgICBkaXNhYmxlT25UYXJnZXQ6IFtdLFxyXG4gICAgfSxcclxuICAgIHBpbmNoOiB7XHJcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxyXG4gICAgfSxcclxuICAgIHpvb21Jbjoge1xyXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICBzdGVwOiAyMCxcclxuICAgICAgICBhbmltYXRpb246IHRydWUsXHJcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogXCJlYXNlT3V0XCIsXHJcbiAgICAgICAgYW5pbWF0aW9uVGltZTogMjAwLFxyXG4gICAgfSxcclxuICAgIHpvb21PdXQ6IHtcclxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgc3RlcDogMjAsXHJcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxyXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IFwiZWFzZU91dFwiLFxyXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDIwMCxcclxuICAgIH0sXHJcbiAgICBkb3VibGVDbGljazoge1xyXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcclxuICAgICAgICBzdGVwOiAyMCxcclxuICAgICAgICBtb2RlOiBcInpvb21JblwiLFxyXG4gICAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcclxuICAgICAgICBhbmltYXRpb25UeXBlOiBcImVhc2VPdXRcIixcclxuICAgICAgICBhbmltYXRpb25UaW1lOiAyMDAsXHJcbiAgICB9LFxyXG4gICAgcmVzZXQ6IHtcclxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxyXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IFwiZWFzZU91dFwiLFxyXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDIwMCxcclxuICAgIH0sXHJcbiAgICBzY2FsZVBhZGRpbmc6IHtcclxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgc2l6ZTogMC4yLFxyXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDIwMCxcclxuICAgICAgICBhbmltYXRpb25UeXBlOiBcImVhc2VPdXRcIixcclxuICAgIH0sXHJcbn07XG5cbi8qKlxyXG4gKiBSb3VuZHMgbnVtYmVyIHRvIGdpdmVuIGRlY2ltYWxcclxuICogZWcuIHJvdW5kTnVtYmVyKDIuMzQzNDMsIDEpID0+IDIuM1xyXG4gKi9cclxudmFyIHJvdW5kTnVtYmVyID0gZnVuY3Rpb24gKG51bSwgZGVjaW1hbCkge1xyXG4gICAgcmV0dXJuIE51bWJlcihudW0udG9GaXhlZChkZWNpbWFsKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdmFsdWUgaXMgbnVtYmVyLCBpZiBub3QgaXQgcmV0dXJucyBkZWZhdWx0IHZhbHVlXHJcbiAqIDEjIGVnLiBjaGVja0lzTnVtYmVyKDIsIDMwKSA9PiAyXHJcbiAqIDIjIGVnLiBjaGVja0lzTnVtYmVyKG51bGwsIDMwKSA9PiAzMFxyXG4gKi9cclxudmFyIGNoZWNrSXNOdW1iZXIgPSBmdW5jdGlvbiAobnVtLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgbnVtID09PSBcIm51bWJlclwiID8gbnVtIDogZGVmYXVsdFZhbHVlO1xyXG59O1xyXG4vKipcclxuICogS2VlcHMgdmFsdWUgYmV0d2VlbiBnaXZlbiBib3VuZHMsIHVzZWQgZm9yIGxpbWl0aW5nIHZpZXcgdG8gZ2l2ZW4gYm91bmRhcmllc1xyXG4gKiAxIyBlZy4gYm91bmRMaW1pdGVyKDIsIDAsIDMsIHRydWUpID0+IDJcclxuICogMiMgZWcuIGJvdW5kTGltaXRlcig0LCAwLCAzLCB0cnVlKSA9PiAzXHJcbiAqIDMjIGVnLiBib3VuZExpbWl0ZXIoLTIsIDAsIDMsIHRydWUpID0+IDBcclxuICogNCMgZWcuIGJvdW5kTGltaXRlcigxMCwgMCwgMywgZmFsc2UpID0+IDEwXHJcbiAqL1xyXG52YXIgYm91bmRMaW1pdGVyID0gZnVuY3Rpb24gKHZhbHVlLCBtaW5Cb3VuZCwgbWF4Qm91bmQsIGlzQWN0aXZlKSB7XHJcbiAgICBpZiAoIWlzQWN0aXZlKVxyXG4gICAgICAgIHJldHVybiByb3VuZE51bWJlcih2YWx1ZSwgMik7XHJcbiAgICBpZiAodmFsdWUgPCBtaW5Cb3VuZClcclxuICAgICAgICByZXR1cm4gcm91bmROdW1iZXIobWluQm91bmQsIDIpO1xyXG4gICAgaWYgKHZhbHVlID4gbWF4Qm91bmQpXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kTnVtYmVyKG1heEJvdW5kLCAyKTtcclxuICAgIHJldHVybiByb3VuZE51bWJlcih2YWx1ZSwgMik7XHJcbn07XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYm91bmRpbmcgYXJlYSBvZiB6b29tZWQvcGFubmVkIGVsZW1lbnRcclxuICovXHJcbnZhciBjYWxjdWxhdGVCb3VuZGluZ0FyZWEgPSBmdW5jdGlvbiAod3JhcHBlcldpZHRoLCBuZXdDb250ZW50V2lkdGgsIGRpZmZXaWR0aCwgd3JhcHBlckhlaWdodCwgbmV3Q29udGVudEhlaWdodCwgZGlmZkhlaWdodCwgbGltaXRUb1dyYXBwZXIpIHtcclxuICAgIHZhciBzY2FsZVdpZHRoRmFjdG9yID0gd3JhcHBlcldpZHRoID4gbmV3Q29udGVudFdpZHRoXHJcbiAgICAgICAgPyBkaWZmV2lkdGggKiAobGltaXRUb1dyYXBwZXIgPyAxIDogMC41KVxyXG4gICAgICAgIDogMDtcclxuICAgIHZhciBzY2FsZUhlaWdodEZhY3RvciA9IHdyYXBwZXJIZWlnaHQgPiBuZXdDb250ZW50SGVpZ2h0XHJcbiAgICAgICAgPyBkaWZmSGVpZ2h0ICogKGxpbWl0VG9XcmFwcGVyID8gMSA6IDAuNSlcclxuICAgICAgICA6IDA7XHJcbiAgICB2YXIgbWluUG9zaXRpb25YID0gd3JhcHBlcldpZHRoIC0gbmV3Q29udGVudFdpZHRoIC0gc2NhbGVXaWR0aEZhY3RvcjtcclxuICAgIHZhciBtYXhQb3NpdGlvblggPSBzY2FsZVdpZHRoRmFjdG9yO1xyXG4gICAgdmFyIG1pblBvc2l0aW9uWSA9IHdyYXBwZXJIZWlnaHQgLSBuZXdDb250ZW50SGVpZ2h0IC0gc2NhbGVIZWlnaHRGYWN0b3I7XHJcbiAgICB2YXIgbWF4UG9zaXRpb25ZID0gc2NhbGVIZWlnaHRGYWN0b3I7XHJcbiAgICByZXR1cm4geyBtaW5Qb3NpdGlvblg6IG1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25YOiBtYXhQb3NpdGlvblgsIG1pblBvc2l0aW9uWTogbWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblk6IG1heFBvc2l0aW9uWSB9O1xyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgeCx5XHJcbiAqL1xyXG52YXIgZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZmlyc3RQb2ludCwgc2Vjb25kUG9pbnQpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZmlyc3RQb2ludC5wYWdlWCAtIHNlY29uZFBvaW50LnBhZ2VYLCAyKSArXHJcbiAgICAgICAgTWF0aC5wb3coZmlyc3RQb2ludC5wYWdlWSAtIHNlY29uZFBvaW50LnBhZ2VZLCAyKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWxldGUgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIG9iamVjdCBrZXlzXHJcbiAqIFVzZWQgZm9yIGRlbGV0aW5nIGVtcHR5IHByb3BzXHJcbiAqL1xyXG52YXIgZGVsZXRlVW5kZWZpbmVkUHJvcHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHZhciBuZXdPYmplY3QgPSBfX2Fzc2lnbih7fSwgdmFsdWUpO1xyXG4gICAgT2JqZWN0LmtleXMobmV3T2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG5ld09iamVjdFtrZXldID09PSB1bmRlZmluZWQgJiYgZGVsZXRlIG5ld09iamVjdFtrZXldOyB9KTtcclxuICAgIHJldHVybiBuZXdPYmplY3Q7XHJcbn07XHJcbi8qKlxyXG4gKiBGaXJlIGNhbGxiYWNrIGlmIGl0J3MgZnVuY3Rpb25cclxuICovXHJcbnZhciBoYW5kbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgcHJvcHMpIHtcclxuICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGNhbGxiYWNrKHByb3BzKTtcclxuICAgIH1cclxufTtcclxudmFyIGhhbmRsZVdoZWVsU3RvcCA9IGZ1bmN0aW9uIChwcmV2aW91c0V2ZW50LCBldmVudCwgc3RhdGVQcm92aWRlcikge1xyXG4gICAgdmFyIHNjYWxlID0gc3RhdGVQcm92aWRlci5zY2FsZSwgX2EgPSBzdGF0ZVByb3ZpZGVyLm9wdGlvbnMsIG1heFNjYWxlID0gX2EubWF4U2NhbGUsIG1pblNjYWxlID0gX2EubWluU2NhbGU7XHJcbiAgICBpZiAoIXByZXZpb3VzRXZlbnQpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKHNjYWxlIDwgbWF4U2NhbGUgfHwgc2NhbGUgPiBtaW5TY2FsZSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChNYXRoLnNpZ24ocHJldmlvdXNFdmVudC5kZWx0YVkpICE9PSBNYXRoLnNpZ24oZXZlbnQuZGVsdGFZKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChwcmV2aW91c0V2ZW50LmRlbHRhWSA+IDAgJiYgcHJldmlvdXNFdmVudC5kZWx0YVkgPCBldmVudC5kZWx0YVkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAocHJldmlvdXNFdmVudC5kZWx0YVkgPCAwICYmIHByZXZpb3VzRXZlbnQuZGVsdGFZID4gZXZlbnQuZGVsdGFZKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKE1hdGguc2lnbihwcmV2aW91c0V2ZW50LmRlbHRhWSkgIT09IE1hdGguc2lnbihldmVudC5kZWx0YVkpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG52YXIgbWVyZ2VQcm9wcyA9IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUsIGR5bmFtaWNQcm9wcykge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGluaXRpYWxTdGF0ZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGR5bmFtaWNQcm9wc1tjdXJyXSA9PT0gXCJvYmplY3RcIiAmJiBkeW5hbWljUHJvcHNbY3Vycl0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgYWNjW2N1cnJdID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxTdGF0ZVtjdXJyXSksIGR5bmFtaWNQcm9wc1tjdXJyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhY2NbY3Vycl0gPVxyXG4gICAgICAgICAgICAgICAgZHluYW1pY1Byb3BzW2N1cnJdID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICA/IGluaXRpYWxTdGF0ZVtjdXJyXVxyXG4gICAgICAgICAgICAgICAgICAgIDogZHluYW1pY1Byb3BzW2N1cnJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG59O1xyXG5mdW5jdGlvbiBnZXRXaW5kb3dTY2FsZVkod3JhcHBlcikge1xyXG4gICAgaWYgKCF3cmFwcGVyKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCAvIHdyYXBwZXIub2Zmc2V0SGVpZ2h0O1xyXG59XHJcbmZ1bmN0aW9uIGdldFdpbmRvd1NjYWxlWCh3cmFwcGVyKSB7XHJcbiAgICBpZiAoIXdyYXBwZXIpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggLyB3cmFwcGVyLm9mZnNldFdpZHRoO1xyXG59XG5cbi8qKlxyXG4gKiBGdW5jdGlvbnMgc2hvdWxkIHJldHVybiBkZW5vbWluYXRvciBvZiB0aGUgdGFyZ2V0IHZhbHVlLCB3aGljaCBpcyB0aGUgbmV4dCBhbmltYXRpb24gc3RlcC5cclxuICogdCBpcyBhIHZhbHVlIGZyb20gMCB0byAxLCByZWZsZWN0aW5nIHRoZSBwZXJjZW50YWdlIG9mIGFuaW1hdGlvbiBzdGF0dXMuXHJcbiAqL1xyXG52YXIgZWFzZU91dCA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICByZXR1cm4gLU1hdGguY29zKHQgKiBNYXRoLlBJKSAvIDIgKyAwLjU7XHJcbn07XHJcbi8vIGxpbmVhclxyXG52YXIgbGluZWFyID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0O1xyXG59O1xyXG4vLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XHJcbnZhciBlYXNlSW5RdWFkID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0ICogdDtcclxufTtcclxuLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcclxudmFyIGVhc2VPdXRRdWFkID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0ICogKDIgLSB0KTtcclxufTtcclxuLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbnZhciBlYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XHJcbn07XHJcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxudmFyIGVhc2VJbkN1YmljID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0ICogdCAqIHQ7XHJcbn07XHJcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbnZhciBlYXNlT3V0Q3ViaWMgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcclxufTtcclxuLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbnZhciBlYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XHJcbn07XHJcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxudmFyIGVhc2VJblF1YXJ0ID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xyXG59O1xyXG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxyXG52YXIgZWFzZU91dFF1YXJ0ID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xyXG59O1xyXG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cclxudmFyIGVhc2VJbk91dFF1YXJ0ID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiB0IDwgMC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcclxufTtcclxuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxyXG52YXIgZWFzZUluUXVpbnQgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xyXG59O1xyXG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxyXG52YXIgZWFzZU91dFF1aW50ID0gZnVuY3Rpb24gKHQpIHtcclxuICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcclxufTtcclxuLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbnZhciBlYXNlSW5PdXRRdWludCA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xyXG59O1xyXG52YXIgYXZhaWxhYmxlQW5pbWF0aW9ucyA9IHtcclxuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXHJcbiAgICBsaW5lYXI6IGxpbmVhcixcclxuICAgIGVhc2VJblF1YWQ6IGVhc2VJblF1YWQsXHJcbiAgICBlYXNlT3V0UXVhZDogZWFzZU91dFF1YWQsXHJcbiAgICBlYXNlSW5PdXRRdWFkOiBlYXNlSW5PdXRRdWFkLFxyXG4gICAgZWFzZUluQ3ViaWM6IGVhc2VJbkN1YmljLFxyXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXHJcbiAgICBlYXNlSW5PdXRDdWJpYzogZWFzZUluT3V0Q3ViaWMsXHJcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXHJcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcclxuICAgIGVhc2VJbk91dFF1YXJ0OiBlYXNlSW5PdXRRdWFydCxcclxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcclxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxyXG4gICAgZWFzZUluT3V0UXVpbnQ6IGVhc2VJbk91dFF1aW50LFxyXG59O1xuXG5mdW5jdGlvbiBoYW5kbGVEaXNhYmxlQW5pbWF0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLm1vdW50ZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb24pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hbmltYXRlID0gZmFsc2U7XHJcbiAgICB0aGlzLmFuaW1hdGlvbiA9IGZhbHNlO1xyXG4gICAgdGhpcy52ZWxvY2l0eSA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGFuaW1hdGUoYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uVGltZSwgY2FsbGJhY2spIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBpZiAoIXRoaXMubW91bnRlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB2YXIgbGFzdFN0ZXAgPSAxO1xyXG4gICAgLy8gaWYgYW5vdGhlciBhbmltYXRpb24gaXMgYWN0aXZlXHJcbiAgICBoYW5kbGVEaXNhYmxlQW5pbWF0aW9uLmNhbGwodGhpcyk7XHJcbiAgICAvLyBuZXcgYW5pbWF0aW9uXHJcbiAgICB0aGlzLmFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIV90aGlzLmFuaW1hdGlvbiB8fCAhX3RoaXMubW91bnRlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcclxuICAgICAgICB2YXIgYW5pbWF0aW9uUHJvZ3Jlc3MgPSBmcmFtZVRpbWUgLyBhbmltYXRpb25UaW1lO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25UeXBlID0gYXZhaWxhYmxlQW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcclxuICAgICAgICB2YXIgc3RlcCA9IGFuaW1hdGlvblR5cGUoYW5pbWF0aW9uUHJvZ3Jlc3MpO1xyXG4gICAgICAgIGlmIChmcmFtZVRpbWUgPj0gYW5pbWF0aW9uVGltZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhsYXN0U3RlcCk7XHJcbiAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhzdGVwKTtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLmFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gYW5pbWF0ZUNvbXBvbmVudChfYSkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciB0YXJnZXRTdGF0ZSA9IF9hLnRhcmdldFN0YXRlLCBzcGVlZCA9IF9hLnNwZWVkLCB0eXBlID0gX2EudHlwZTtcclxuICAgIHZhciBfYiA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYi5zY2FsZSwgcG9zaXRpb25YID0gX2IucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYi5wb3NpdGlvblk7XHJcbiAgICB2YXIgc2NhbGVEaWZmID0gdGFyZ2V0U3RhdGUuc2NhbGUgLSBzY2FsZTtcclxuICAgIHZhciBwb3NpdGlvblhEaWZmID0gdGFyZ2V0U3RhdGUucG9zaXRpb25YIC0gcG9zaXRpb25YO1xyXG4gICAgdmFyIHBvc2l0aW9uWURpZmYgPSB0YXJnZXRTdGF0ZS5wb3NpdGlvblkgLSBwb3NpdGlvblk7XHJcbiAgICBpZiAoc3BlZWQgPT09IDApIHtcclxuICAgICAgICB0aGlzLnN0YXRlUHJvdmlkZXIucHJldmlvdXNTY2FsZSA9IHRoaXMuc3RhdGVQcm92aWRlci5zY2FsZTtcclxuICAgICAgICB0aGlzLnN0YXRlUHJvdmlkZXIuc2NhbGUgPSB0YXJnZXRTdGF0ZS5zY2FsZTtcclxuICAgICAgICB0aGlzLnN0YXRlUHJvdmlkZXIucG9zaXRpb25YID0gdGFyZ2V0U3RhdGUucG9zaXRpb25YO1xyXG4gICAgICAgIHRoaXMuc3RhdGVQcm92aWRlci5wb3NpdGlvblkgPSB0YXJnZXRTdGF0ZS5wb3NpdGlvblk7XHJcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBhbmltYXRpb24gc3RhcnQgdGltZXN0YW1wXHJcbiAgICAgICAgYW5pbWF0ZS5jYWxsKHRoaXMsIHR5cGUsIHNwZWVkLCBmdW5jdGlvbiAoc3RlcCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyLnByZXZpb3VzU2NhbGUgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLnNjYWxlO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyLnNjYWxlID0gc2NhbGUgKyBzY2FsZURpZmYgKiBzdGVwO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyLnBvc2l0aW9uWCA9IHBvc2l0aW9uWCArIHBvc2l0aW9uWERpZmYgKiBzdGVwO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyLnBvc2l0aW9uWSA9IHBvc2l0aW9uWSArIHBvc2l0aW9uWURpZmYgKiBzdGVwO1xyXG4gICAgICAgICAgICAvLyBhcHBseSBhbmltYXRpb24gY2hhbmdlc1xyXG4gICAgICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY2hlY2tab29tQm91bmRzKHpvb20sIG1pblNjYWxlLCBtYXhTY2FsZSwgem9vbVBhZGRpbmcsIGVuYWJsZVBhZGRpbmcpIHtcclxuICAgIHZhciBzY2FsZVBhZGRpbmcgPSBlbmFibGVQYWRkaW5nID8gem9vbVBhZGRpbmcgOiAwO1xyXG4gICAgdmFyIG1pblNjYWxlV2l0aFBhZGRpbmcgPSBtaW5TY2FsZSAtIHNjYWxlUGFkZGluZztcclxuICAgIGlmICghaXNOYU4obWF4U2NhbGUpICYmIHpvb20gPj0gbWF4U2NhbGUpXHJcbiAgICAgICAgcmV0dXJuIG1heFNjYWxlO1xyXG4gICAgaWYgKCFpc05hTihtaW5TY2FsZSkgJiYgem9vbSA8PSBtaW5TY2FsZVdpdGhQYWRkaW5nKVxyXG4gICAgICAgIHJldHVybiBtaW5TY2FsZVdpdGhQYWRkaW5nO1xyXG4gICAgcmV0dXJuIHpvb207XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tQb3NpdGlvbkJvdW5kcyhwb3NpdGlvblgsIHBvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWUsIHdyYXBwZXJDb21wb25lbnQpIHtcclxuICAgIHZhciBtaW5Qb3NpdGlvblggPSBib3VuZHMubWluUG9zaXRpb25YLCBtaW5Qb3NpdGlvblkgPSBib3VuZHMubWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblggPSBib3VuZHMubWF4UG9zaXRpb25YLCBtYXhQb3NpdGlvblkgPSBib3VuZHMubWF4UG9zaXRpb25ZO1xyXG4gICAgdmFyIHBhZGRpbmdYID0gd3JhcHBlckNvbXBvbmVudFxyXG4gICAgICAgID8gKHBhZGRpbmdWYWx1ZSAqIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGgpIC8gMTAwXHJcbiAgICAgICAgOiAwO1xyXG4gICAgdmFyIHBhZGRpbmdZID0gd3JhcHBlckNvbXBvbmVudFxyXG4gICAgICAgID8gKHBhZGRpbmdWYWx1ZSAqIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0KSAvIDEwMFxyXG4gICAgICAgIDogMDtcclxuICAgIHZhciB4ID0gYm91bmRMaW1pdGVyKHBvc2l0aW9uWCwgbWluUG9zaXRpb25YIC0gcGFkZGluZ1gsIG1heFBvc2l0aW9uWCArIHBhZGRpbmdYLCBsaW1pdFRvQm91bmRzKTtcclxuICAgIHZhciB5ID0gYm91bmRMaW1pdGVyKHBvc2l0aW9uWSwgbWluUG9zaXRpb25ZIC0gcGFkZGluZ1ksIG1heFBvc2l0aW9uWSArIHBhZGRpbmdZLCBsaW1pdFRvQm91bmRzKTtcclxuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcclxufVxyXG5mdW5jdGlvbiBnZXREZWx0YShldmVudCwgY3VzdG9tRGVsdGEpIHtcclxuICAgIHZhciBkZWx0YVkgPSBldmVudCA/IChldmVudC5kZWx0YVkgPCAwID8gMSA6IC0xKSA6IDA7XHJcbiAgICB2YXIgZGVsdGEgPSBjaGVja0lzTnVtYmVyKGN1c3RvbURlbHRhLCBkZWx0YVkpO1xyXG4gICAgcmV0dXJuIGRlbHRhO1xyXG59XHJcbmZ1bmN0aW9uIHdoZWVsTW91c2VQb3NpdGlvbihldmVudCwgY29udGVudENvbXBvbmVudCwgc2NhbGUpIHtcclxuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRDb21wb25lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAvLyBtb3VzZSBwb3NpdGlvbiB4LCB5IG92ZXIgd3JhcHBlciBjb21wb25lbnRcclxuICAgIHZhciBtb3VzZVggPSAoZXZlbnQuY2xpZW50WCAtIGNvbnRlbnRSZWN0LmxlZnQpIC8gc2NhbGU7XHJcbiAgICB2YXIgbW91c2VZID0gKGV2ZW50LmNsaWVudFkgLSBjb250ZW50UmVjdC50b3ApIC8gc2NhbGU7XHJcbiAgICBpZiAoaXNOYU4obW91c2VYKSB8fCBpc05hTihtb3VzZVkpKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBtb3VzZSBvciB0b3VjaCBvZmZzZXQgZm91bmRcIik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1vdXNlWDogbW91c2VYLFxyXG4gICAgICAgIG1vdXNlWTogbW91c2VZLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzU2l6ZXMod3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCwgbmV3U2NhbGUpIHtcclxuICAgIHZhciB3cmFwcGVyV2lkdGggPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgdmFyIHdyYXBwZXJIZWlnaHQgPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodDtcclxuICAgIHZhciBjb250ZW50V2lkdGggPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldEhlaWdodDtcclxuICAgIHZhciBuZXdDb250ZW50V2lkdGggPSBjb250ZW50V2lkdGggKiBuZXdTY2FsZTtcclxuICAgIHZhciBuZXdDb250ZW50SGVpZ2h0ID0gY29udGVudEhlaWdodCAqIG5ld1NjYWxlO1xyXG4gICAgdmFyIG5ld0RpZmZXaWR0aCA9IHdyYXBwZXJXaWR0aCAtIG5ld0NvbnRlbnRXaWR0aDtcclxuICAgIHZhciBuZXdEaWZmSGVpZ2h0ID0gd3JhcHBlckhlaWdodCAtIG5ld0NvbnRlbnRIZWlnaHQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdyYXBwZXJXaWR0aDogd3JhcHBlcldpZHRoLFxyXG4gICAgICAgIHdyYXBwZXJIZWlnaHQ6IHdyYXBwZXJIZWlnaHQsXHJcbiAgICAgICAgbmV3Q29udGVudFdpZHRoOiBuZXdDb250ZW50V2lkdGgsXHJcbiAgICAgICAgbmV3RGlmZldpZHRoOiBuZXdEaWZmV2lkdGgsXHJcbiAgICAgICAgbmV3Q29udGVudEhlaWdodDogbmV3Q29udGVudEhlaWdodCxcclxuICAgICAgICBuZXdEaWZmSGVpZ2h0OiBuZXdEaWZmSGVpZ2h0LFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVDYWxjdWxhdGVQb3NpdGlvbnMobW91c2VYLCBtb3VzZVksIG5ld1NjYWxlLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMpIHtcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblksIHRyYW5zZm9ybUVuYWJsZWQgPSBfYS5vcHRpb25zLnRyYW5zZm9ybUVuYWJsZWQ7XHJcbiAgICB2YXIgc2NhbGVEaWZmZXJlbmNlID0gbmV3U2NhbGUgLSBzY2FsZTtcclxuICAgIGlmICh0eXBlb2YgbW91c2VYICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBtb3VzZVkgIT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJNb3VzZSBYIGFuZCBZIHBvc2l0aW9uIHdlcmUgbm90IHByb3ZpZGVkIVwiKTtcclxuICAgIGlmICghdHJhbnNmb3JtRW5hYmxlZClcclxuICAgICAgICByZXR1cm4geyBuZXdQb3NpdGlvblg6IHBvc2l0aW9uWCwgbmV3UG9zaXRpb25ZOiBwb3NpdGlvblkgfTtcclxuICAgIHZhciBjYWxjdWxhdGVkUG9zaXRpb25YID0gcG9zaXRpb25YIC0gbW91c2VYICogc2NhbGVEaWZmZXJlbmNlO1xyXG4gICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvblkgPSBwb3NpdGlvblkgLSBtb3VzZVkgKiBzY2FsZURpZmZlcmVuY2U7XHJcbiAgICAvLyBkbyBub3QgbGltaXQgdG8gYm91bmRzIHdoZW4gdGhlcmUgaXMgcGFkZGluZyBhbmltYXRpb24sXHJcbiAgICAvLyBpdCBjYXVzZXMgYW5pbWF0aW9uIHN0cmFuZ2UgYmVoYXZpb3VyXHJcbiAgICB2YXIgbmV3UG9zaXRpb25zID0gY2hlY2tQb3NpdGlvbkJvdW5kcyhjYWxjdWxhdGVkUG9zaXRpb25YLCBjYWxjdWxhdGVkUG9zaXRpb25ZLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMsIDAsIG51bGwpO1xyXG4gICAgcmV0dXJuIG5ld1Bvc2l0aW9ucztcclxufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRQb3NpdGlvbihldmVudCkge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xyXG4gICAgLy8gTW9iaWxlIHBvaW50c1xyXG4gICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICByZXR1cm4geyBjbGllbnRYOiB0b3VjaGVzWzBdLmNsaWVudFgsIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WSB9O1xyXG4gICAgfVxyXG4gICAgLy8gRGVza3RvcCBwb2ludHNcclxuICAgIGlmICghdG91Y2hlcykge1xyXG4gICAgICAgIHJldHVybiB7IGNsaWVudFg6IGV2ZW50LmNsaWVudFgsIGNsaWVudFk6IGV2ZW50LmNsaWVudFkgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVBhbm5pbmcoZXZlbnQpIHtcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblksIF9iID0gX2Eub3B0aW9ucywgbGltaXRUb0JvdW5kcyA9IF9iLmxpbWl0VG9Cb3VuZHMsIG1pblNjYWxlID0gX2IubWluU2NhbGUsIF9jID0gX2EucGFuLCBsb2NrQXhpc1ggPSBfYy5sb2NrQXhpc1gsIGxvY2tBeGlzWSA9IF9jLmxvY2tBeGlzWSwgcGFkZGluZyA9IF9jLnBhZGRpbmcsIHBhZGRpbmdTaXplID0gX2MucGFkZGluZ1NpemUsIHdyYXBwZXJDb21wb25lbnQgPSBfYS53cmFwcGVyQ29tcG9uZW50O1xyXG4gICAgaWYgKCF0aGlzLnN0YXJ0Q29vcmRzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBfZCA9IHRoaXMuc3RhcnRDb29yZHMsIHggPSBfZC54LCB5ID0gX2QueTtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBnZXRDbGllbnRQb3NpdGlvbihldmVudCk7XHJcbiAgICBpZiAoIXBvc2l0aW9ucylcclxuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkNhbm5vdCBmaW5kIG1vdXNlIGNsaWVudCBwb3NpdGlvbnNcIik7XHJcbiAgICB2YXIgY2xpZW50WCA9IHBvc2l0aW9ucy5jbGllbnRYLCBjbGllbnRZID0gcG9zaXRpb25zLmNsaWVudFk7XHJcbiAgICAvLyBHZXQgUG9zaXRpb25cclxuICAgIHZhciBtb3VzZVggPSBjbGllbnRYIC0geDtcclxuICAgIHZhciBtb3VzZVkgPSBjbGllbnRZIC0geTtcclxuICAgIHZhciBuZXdQb3NpdGlvblggPSBsb2NrQXhpc1ggPyBwb3NpdGlvblggOiBtb3VzZVg7XHJcbiAgICB2YXIgbmV3UG9zaXRpb25ZID0gbG9ja0F4aXNZID8gcG9zaXRpb25ZIDogbW91c2VZO1xyXG4gICAgLy8gcGFkZGluZ1xyXG4gICAgdmFyIHBhZGRpbmdWYWx1ZSA9IHBhZGRpbmcgJiYgc2NhbGUgPj0gbWluU2NhbGUgPyBwYWRkaW5nU2l6ZSA6IDA7XHJcbiAgICAvLyBJZiBwb3NpdGlvbiBkaWRuJ3QgY2hhbmdlXHJcbiAgICBpZiAobmV3UG9zaXRpb25YID09PSBwb3NpdGlvblggJiYgbmV3UG9zaXRpb25ZID09PSBwb3NpdGlvblkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvbiA9IGNoZWNrUG9zaXRpb25Cb3VuZHMobmV3UG9zaXRpb25YLCBuZXdQb3NpdGlvblksIHRoaXMuYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWUsIHdyYXBwZXJDb21wb25lbnQpO1xyXG4gICAgLy8gU2F2ZSBwYW5uZWQgcG9zaXRpb25cclxuICAgIGhhbmRsZVBhZGRpbmdBbmltYXRpb24uY2FsbCh0aGlzLCBjYWxjdWxhdGVkUG9zaXRpb24ueCwgY2FsY3VsYXRlZFBvc2l0aW9uLnkpO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVBhbm5pbmdBbmltYXRpb24oKSB7XHJcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlUHJvdmlkZXIsIHNjYWxlID0gX2Euc2NhbGUsIG1pblNjYWxlID0gX2Eub3B0aW9ucy5taW5TY2FsZSwgX2IgPSBfYS5wYW4sIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIHBhZGRpbmcgPSBfYi5wYWRkaW5nLCBwYW5SZXR1cm5BbmltYXRpb25UaW1lID0gX2IucGFuUmV0dXJuQW5pbWF0aW9uVGltZSwgcGFuUmV0dXJuQW5pbWF0aW9uVHlwZSA9IF9iLnBhblJldHVybkFuaW1hdGlvblR5cGU7XHJcbiAgICB2YXIgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8IHNjYWxlIDwgbWluU2NhbGUgfHwgIXBhZGRpbmc7XHJcbiAgICBpZiAoaXNEaXNhYmxlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSBoYW5kbGVQYW5Ub0JvdW5kcy5jYWxsKHRoaXMpO1xyXG4gICAgYW5pbWF0ZUNvbXBvbmVudC5jYWxsKHRoaXMsIHtcclxuICAgICAgICB0YXJnZXRTdGF0ZTogdGFyZ2V0U3RhdGUsXHJcbiAgICAgICAgc3BlZWQ6IHBhblJldHVybkFuaW1hdGlvblRpbWUsXHJcbiAgICAgICAgdHlwZTogcGFuUmV0dXJuQW5pbWF0aW9uVHlwZSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVBhblRvQm91bmRzKCkge1xyXG4gICAgdmFyIF9hID0gdGhpcy5zdGF0ZVByb3ZpZGVyLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWSwgc2NhbGUgPSBfYS5zY2FsZSwgX2IgPSBfYS5vcHRpb25zLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBsaW1pdFRvQm91bmRzID0gX2IubGltaXRUb0JvdW5kcywgbGltaXRUb1dyYXBwZXIgPSBfYi5saW1pdFRvV3JhcHBlcjtcclxuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gdGhpcy5zdGF0ZS53cmFwcGVyQ29tcG9uZW50O1xyXG4gICAgaWYgKGRpc2FibGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBfYyA9IHRoaXMuYm91bmRzLCBtYXhQb3NpdGlvblggPSBfYy5tYXhQb3NpdGlvblgsIG1pblBvc2l0aW9uWCA9IF9jLm1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25ZID0gX2MubWF4UG9zaXRpb25ZLCBtaW5Qb3NpdGlvblkgPSBfYy5taW5Qb3NpdGlvblk7XHJcbiAgICB2YXIgeENoYW5nZWQgPSBwb3NpdGlvblggPiBtYXhQb3NpdGlvblggfHwgcG9zaXRpb25YIDwgbWluUG9zaXRpb25YO1xyXG4gICAgdmFyIHlDaGFuZ2VkID0gcG9zaXRpb25ZID4gbWF4UG9zaXRpb25ZIHx8IHBvc2l0aW9uWSA8IG1pblBvc2l0aW9uWTtcclxuICAgIHZhciBtb3VzZVggPSBwb3NpdGlvblggPiBtYXhQb3NpdGlvblhcclxuICAgICAgICA/IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGhcclxuICAgICAgICA6IHRoaXMuc3RhdGVQcm92aWRlci5taW5Qb3NpdGlvblggfHwgMDtcclxuICAgIHZhciBtb3VzZVkgPSBwb3NpdGlvblkgPiBtYXhQb3NpdGlvbllcclxuICAgICAgICA/IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgOiB0aGlzLnN0YXRlUHJvdmlkZXIubWluUG9zaXRpb25ZIHx8IDA7XHJcbiAgICB2YXIgbW91c2VQb3NYID0gbW91c2VYO1xyXG4gICAgdmFyIG1vdXNlUG9zWSA9IG1vdXNlWTtcclxuICAgIHZhciBfZCA9IGhhbmRsZUNhbGN1bGF0ZVBvc2l0aW9ucy5jYWxsKHRoaXMsIG1vdXNlUG9zWCwgbW91c2VQb3NZLCBzY2FsZSwgdGhpcy5ib3VuZHMsIGxpbWl0VG9Cb3VuZHMgfHwgbGltaXRUb1dyYXBwZXIpLCB4ID0gX2QueCwgeSA9IF9kLnk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNjYWxlOiBzY2FsZSxcclxuICAgICAgICBwb3NpdGlvblg6IHhDaGFuZ2VkID8geCA6IHBvc2l0aW9uWCxcclxuICAgICAgICBwb3NpdGlvblk6IHlDaGFuZ2VkID8geSA6IHBvc2l0aW9uWSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlUGFkZGluZ0FuaW1hdGlvbihwb3NpdGlvblgsIHBvc2l0aW9uWSkge1xyXG4gICAgdmFyIHBhZGRpbmcgPSB0aGlzLnN0YXRlUHJvdmlkZXIucGFuLnBhZGRpbmc7XHJcbiAgICBpZiAoIXBhZGRpbmcpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdGhpcy5zdGF0ZVByb3ZpZGVyLnBvc2l0aW9uWCA9IHBvc2l0aW9uWDtcclxuICAgIHRoaXMuc3RhdGVQcm92aWRlci5wb3NpdGlvblkgPSBwb3NpdGlvblk7XHJcbiAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24oKTtcclxufVxuXG5mdW5jdGlvbiBoYW5kbGVDYWxjdWxhdGVab29tKGRlbHRhLCBzdGVwLCBkaXNhYmxlUGFkZGluZywgZ2V0VGFyZ2V0LCBpc0J0bkZ1bmN0aW9uKSB7XHJcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlUHJvdmlkZXIsIHNjYWxlID0gX2Euc2NhbGUsIF9iID0gX2Eub3B0aW9ucywgbWF4U2NhbGUgPSBfYi5tYXhTY2FsZSwgbWluU2NhbGUgPSBfYi5taW5TY2FsZSwgX2MgPSBfYS5zY2FsZVBhZGRpbmcsIHNpemUgPSBfYy5zaXplLCBkaXNhYmxlZCA9IF9jLmRpc2FibGVkLCB3cmFwcGVyQ29tcG9uZW50ID0gX2Eud3JhcHBlckNvbXBvbmVudDtcclxuICAgIHZhciB0YXJnZXRTY2FsZSA9IG51bGw7XHJcbiAgICBpZiAoaXNCdG5GdW5jdGlvbikge1xyXG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IHdpbmRvdy5pbm5lcldpZHRoICogMC4wMDAxO1xyXG4gICAgICAgIHZhciB6b29tRmFjdG9yID0gZGVsdGEgPCAwID8gMzAgOiAyMDtcclxuICAgICAgICB0YXJnZXRTY2FsZSA9XHJcbiAgICAgICAgICAgIHNjYWxlICsgKHN0ZXAgLSBzdGVwICogc2NhbGVGYWN0b3IpICogZGVsdGEgKiAoc2NhbGUgLyB6b29tRmFjdG9yKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciB3cmFwcGVyVG9XaW5kb3dTY2FsZSA9IDIgLSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gTWF0aC5tYXgoMC4yLCBNYXRoLm1pbigwLjk5LCB3cmFwcGVyVG9XaW5kb3dTY2FsZSkpO1xyXG4gICAgICAgIHZhciB6b29tRmFjdG9yID0gMjA7XHJcbiAgICAgICAgdGFyZ2V0U2NhbGUgPVxyXG4gICAgICAgICAgICBzY2FsZSArIHN0ZXAgKiBkZWx0YSAqICgoc2NhbGUgLSBzY2FsZSAqIHNjYWxlRmFjdG9yKSAvIHpvb21GYWN0b3IpO1xyXG4gICAgfVxyXG4gICAgaWYgKGdldFRhcmdldClcclxuICAgICAgICByZXR1cm4gdGFyZ2V0U2NhbGU7XHJcbiAgICB2YXIgcGFkZGluZ0VuYWJsZWQgPSBkaXNhYmxlUGFkZGluZyA/IGZhbHNlIDogIWRpc2FibGVkO1xyXG4gICAgdmFyIG5ld1NjYWxlID0gY2hlY2tab29tQm91bmRzKHJvdW5kTnVtYmVyKHRhcmdldFNjYWxlLCAzKSwgbWluU2NhbGUsIG1heFNjYWxlLCBzaXplLCBwYWRkaW5nRW5hYmxlZCk7XHJcbiAgICByZXR1cm4gbmV3U2NhbGU7XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlQ2FsY3VsYXRlQm91bmRzKG5ld1NjYWxlLCBsaW1pdFRvV3JhcHBlcikge1xyXG4gICAgdmFyIF9hID0gdGhpcy5zdGF0ZVByb3ZpZGVyLCB3cmFwcGVyQ29tcG9uZW50ID0gX2Eud3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCA9IF9hLmNvbnRlbnRDb21wb25lbnQ7XHJcbiAgICB2YXIgX2IgPSBnZXRDb21wb25lbnRzU2l6ZXMod3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCwgbmV3U2NhbGUpLCB3cmFwcGVyV2lkdGggPSBfYi53cmFwcGVyV2lkdGgsIHdyYXBwZXJIZWlnaHQgPSBfYi53cmFwcGVySGVpZ2h0LCBuZXdDb250ZW50V2lkdGggPSBfYi5uZXdDb250ZW50V2lkdGgsIG5ld0RpZmZXaWR0aCA9IF9iLm5ld0RpZmZXaWR0aCwgbmV3Q29udGVudEhlaWdodCA9IF9iLm5ld0NvbnRlbnRIZWlnaHQsIG5ld0RpZmZIZWlnaHQgPSBfYi5uZXdEaWZmSGVpZ2h0O1xyXG4gICAgdmFyIGJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kaW5nQXJlYSh3cmFwcGVyV2lkdGgsIG5ld0NvbnRlbnRXaWR0aCwgbmV3RGlmZldpZHRoLCB3cmFwcGVySGVpZ2h0LCBuZXdDb250ZW50SGVpZ2h0LCBuZXdEaWZmSGVpZ2h0LCBsaW1pdFRvV3JhcHBlcik7XHJcbiAgICAvLyBTYXZlIGJvdW5kc1xyXG4gICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XHJcbiAgICByZXR1cm4gYm91bmRzO1xyXG59XHJcbi8qKlxyXG4gKiBXaGVlbCB6b29tIGV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBoYW5kbGVXaGVlbFpvb20oZXZlbnQpIHtcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYS5zY2FsZSwgY29udGVudENvbXBvbmVudCA9IF9hLmNvbnRlbnRDb21wb25lbnQsIGxpbWl0VG9Cb3VuZHMgPSBfYS5vcHRpb25zLmxpbWl0VG9Cb3VuZHMsIF9iID0gX2Euc2NhbGVQYWRkaW5nLCBzaXplID0gX2Iuc2l6ZSwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgX2MgPSBfYS53aGVlbCwgc3RlcCA9IF9jLnN0ZXAsIGxpbWl0c09uV2hlZWwgPSBfYy5saW1pdHNPbldoZWVsO1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgdmFyIGRlbHRhID0gZ2V0RGVsdGEoZXZlbnQsIG51bGwpO1xyXG4gICAgdmFyIG5ld1NjYWxlID0gaGFuZGxlQ2FsY3VsYXRlWm9vbS5jYWxsKHRoaXMsIGRlbHRhLCBzdGVwLCAhZXZlbnQuY3RybEtleSk7XHJcbiAgICAvLyBpZiBzY2FsZSBub3QgY2hhbmdlXHJcbiAgICBpZiAoc2NhbGUgPT09IG5ld1NjYWxlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBib3VuZHMgPSBoYW5kbGVDYWxjdWxhdGVCb3VuZHMuY2FsbCh0aGlzLCBuZXdTY2FsZSwgIWxpbWl0c09uV2hlZWwpO1xyXG4gICAgdmFyIF9kID0gd2hlZWxNb3VzZVBvc2l0aW9uKGV2ZW50LCBjb250ZW50Q29tcG9uZW50LCBzY2FsZSksIG1vdXNlWCA9IF9kLm1vdXNlWCwgbW91c2VZID0gX2QubW91c2VZO1xyXG4gICAgdmFyIGlzTGltaXRlZFRvQm91bmRzID0gbGltaXRUb0JvdW5kcyAmJiAoZGlzYWJsZWQgfHwgc2l6ZSA9PT0gMCB8fCBsaW1pdHNPbldoZWVsKTtcclxuICAgIHZhciBfZSA9IGhhbmRsZUNhbGN1bGF0ZVBvc2l0aW9ucy5jYWxsKHRoaXMsIG1vdXNlWCwgbW91c2VZLCBuZXdTY2FsZSwgYm91bmRzLCBpc0xpbWl0ZWRUb0JvdW5kcyksIHggPSBfZS54LCB5ID0gX2UueTtcclxuICAgIHRoaXMuYm91bmRzID0gYm91bmRzO1xyXG4gICAgdGhpcy5zdGF0ZVByb3ZpZGVyLnByZXZpb3VzU2NhbGUgPSBzY2FsZTtcclxuICAgIHRoaXMuc3RhdGVQcm92aWRlci5zY2FsZSA9IG5ld1NjYWxlO1xyXG4gICAgdGhpcy5zdGF0ZVByb3ZpZGVyLnBvc2l0aW9uWCA9IHg7XHJcbiAgICB0aGlzLnN0YXRlUHJvdmlkZXIucG9zaXRpb25ZID0geTtcclxuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbigpO1xyXG59XHJcbi8qKlxyXG4gKiBab29tIGZvciBhbmltYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBoYW5kbGVab29tVG9Qb2ludChpc0Rpc2FibGVkLCBzY2FsZSwgbW91c2VYLCBtb3VzZVksIGV2ZW50KSB7XHJcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlUHJvdmlkZXIsIGNvbnRlbnRDb21wb25lbnQgPSBfYS5jb250ZW50Q29tcG9uZW50LCBfYiA9IF9hLm9wdGlvbnMsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIG1pblNjYWxlID0gX2IubWluU2NhbGUsIG1heFNjYWxlID0gX2IubWF4U2NhbGUsIGxpbWl0VG9Cb3VuZHMgPSBfYi5saW1pdFRvQm91bmRzLCBsaW1pdFRvV3JhcHBlciA9IF9iLmxpbWl0VG9XcmFwcGVyO1xyXG4gICAgaWYgKGRpc2FibGVkIHx8IGlzRGlzYWJsZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIG5ld1NjYWxlID0gY2hlY2tab29tQm91bmRzKHJvdW5kTnVtYmVyKHNjYWxlLCAyKSwgbWluU2NhbGUsIG1heFNjYWxlLCBudWxsLCBudWxsKTtcclxuICAgIHZhciBib3VuZHMgPSBoYW5kbGVDYWxjdWxhdGVCb3VuZHMuY2FsbCh0aGlzLCBuZXdTY2FsZSwgbGltaXRUb1dyYXBwZXIpO1xyXG4gICAgdmFyIG1vdXNlUG9zWCA9IG1vdXNlWDtcclxuICAgIHZhciBtb3VzZVBvc1kgPSBtb3VzZVk7XHJcbiAgICAvLyBpZiBldmVudCBpcyBwcmVzZW50IC0gdXNlIGl0J3MgbW91c2UgcG9zaXRpb25cclxuICAgIGlmIChldmVudCkge1xyXG4gICAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gd2hlZWxNb3VzZVBvc2l0aW9uKGV2ZW50LCBjb250ZW50Q29tcG9uZW50LCBzY2FsZSk7XHJcbiAgICAgICAgbW91c2VQb3NYID0gbW91c2VQb3NpdGlvbi5tb3VzZVg7XHJcbiAgICAgICAgbW91c2VQb3NZID0gbW91c2VQb3NpdGlvbi5tb3VzZVk7XHJcbiAgICB9XHJcbiAgICB2YXIgX2MgPSBoYW5kbGVDYWxjdWxhdGVQb3NpdGlvbnMuY2FsbCh0aGlzLCBtb3VzZVBvc1gsIG1vdXNlUG9zWSwgbmV3U2NhbGUsIGJvdW5kcywgbGltaXRUb0JvdW5kcyksIHggPSBfYy54LCB5ID0gX2MueTtcclxuICAgIHJldHVybiB7IHNjYWxlOiBuZXdTY2FsZSwgcG9zaXRpb25YOiB4LCBwb3NpdGlvblk6IHkgfTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVQYWRkaW5nQW5pbWF0aW9uJDEoKSB7XHJcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlUHJvdmlkZXIsIHNjYWxlID0gX2Euc2NhbGUsIHdyYXBwZXJDb21wb25lbnQgPSBfYS53cmFwcGVyQ29tcG9uZW50LCBfYiA9IF9hLm9wdGlvbnMsIG1pblNjYWxlID0gX2IubWluU2NhbGUsIGxpbWl0VG9Cb3VuZHMgPSBfYi5saW1pdFRvQm91bmRzLCBfYyA9IF9hLnNjYWxlUGFkZGluZywgZGlzYWJsZWQgPSBfYy5kaXNhYmxlZCwgYW5pbWF0aW9uVGltZSA9IF9jLmFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUgPSBfYy5hbmltYXRpb25UeXBlO1xyXG4gICAgdmFyIGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCBzY2FsZSA+PSBtaW5TY2FsZTtcclxuICAgIGlmIChzY2FsZSA+PSAxIHx8IGxpbWl0VG9Cb3VuZHMpIHtcclxuICAgICAgICAvLyBmaXJlIGZpdCB0byBib3VuZHMgYW5pbWF0aW9uXHJcbiAgICAgICAgaGFuZGxlUGFubmluZ0FuaW1hdGlvbi5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRGlzYWJsZWQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIG1vdXNlWCA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGggLyAyO1xyXG4gICAgdmFyIG1vdXNlWSA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0IC8gMjtcclxuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50LmNhbGwodGhpcywgZmFsc2UsIG1pblNjYWxlLCBtb3VzZVgsIG1vdXNlWSwgbnVsbCk7XHJcbiAgICBhbmltYXRlQ29tcG9uZW50LmNhbGwodGhpcywge1xyXG4gICAgICAgIHRhcmdldFN0YXRlOiB0YXJnZXRTdGF0ZSxcclxuICAgICAgICBzcGVlZDogYW5pbWF0aW9uVGltZSxcclxuICAgICAgICB0eXBlOiBhbmltYXRpb25UeXBlLFxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEJ1dHRvbiB6b29tIGV2ZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2soZXZlbnQpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgY29udGVudENvbXBvbmVudCA9IF9hLmNvbnRlbnRDb21wb25lbnQsIHNjYWxlID0gX2Euc2NhbGUsIF9iID0gX2EuZG91YmxlQ2xpY2ssIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIG1vZGUgPSBfYi5tb2RlLCBzdGVwID0gX2Iuc3RlcCwgYW5pbWF0aW9uVGltZSA9IF9iLmFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUgPSBfYi5hbmltYXRpb25UeXBlO1xyXG4gICAgaWYgKG1vZGUgPT09IFwicmVzZXRcIikge1xyXG4gICAgICAgIHJldHVybiByZXNldFRyYW5zZm9ybWF0aW9ucy5jYWxsKHRoaXMsIGV2ZW50LCBhbmltYXRpb25UaW1lKTtcclxuICAgIH1cclxuICAgIHZhciBkZWx0YSA9IG1vZGUgPT09IFwiem9vbU91dFwiID8gLTEgOiAxO1xyXG4gICAgdmFyIG5ld1NjYWxlID0gaGFuZGxlQ2FsY3VsYXRlWm9vbS5jYWxsKHRoaXMsIGRlbHRhLCBzdGVwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICB2YXIgX2MgPSB3aGVlbE1vdXNlUG9zaXRpb24oZXZlbnQsIGNvbnRlbnRDb21wb25lbnQsIHNjYWxlKSwgbW91c2VYID0gX2MubW91c2VYLCBtb3VzZVkgPSBfYy5tb3VzZVk7XHJcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSBoYW5kbGVab29tVG9Qb2ludC5jYWxsKHRoaXMsIGRpc2FibGVkLCBuZXdTY2FsZSwgbW91c2VYLCBtb3VzZVkpO1xyXG4gICAgaWYgKHRhcmdldFN0YXRlLnNjYWxlID09PSBzY2FsZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgdGFyZ2V0U2NhbGUgPSBoYW5kbGVDYWxjdWxhdGVab29tLmNhbGwodGhpcywgZGVsdGEsIHN0ZXAsIHRydWUsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcbiAgICB2YXIgdGltZSA9IGdldEJ1dHRvbkFuaW1hdGlvblRpbWUodGFyZ2V0U2NhbGUsIG5ld1NjYWxlLCBhbmltYXRpb25UaW1lKTtcclxuICAgIGFuaW1hdGVDb21wb25lbnQuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgdGFyZ2V0U3RhdGU6IHRhcmdldFN0YXRlLFxyXG4gICAgICAgIHNwZWVkOiB0aW1lLFxyXG4gICAgICAgIHR5cGU6IGFuaW1hdGlvblR5cGUsXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVab29tQ29udHJvbHMoY3VzdG9tRGVsdGEsIGN1c3RvbVN0ZXApIHtcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblksIHdyYXBwZXJDb21wb25lbnQgPSBfYS53cmFwcGVyQ29tcG9uZW50LCB6b29tSW4gPSBfYS56b29tSW4sIHpvb21PdXQgPSBfYS56b29tT3V0O1xyXG4gICAgdmFyIHdyYXBwZXJXaWR0aCA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGg7XHJcbiAgICB2YXIgd3JhcHBlckhlaWdodCA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgdmFyIG1vdXNlWCA9ICh3cmFwcGVyV2lkdGggLyAyIC0gcG9zaXRpb25YKSAvIHNjYWxlO1xyXG4gICAgdmFyIG1vdXNlWSA9ICh3cmFwcGVySGVpZ2h0IC8gMiAtIHBvc2l0aW9uWSkgLyBzY2FsZTtcclxuICAgIHZhciBuZXdTY2FsZSA9IGhhbmRsZUNhbGN1bGF0ZVpvb20uY2FsbCh0aGlzLCBjdXN0b21EZWx0YSwgY3VzdG9tU3RlcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgdmFyIGlzWm9vbUluID0gbmV3U2NhbGUgPiBzY2FsZTtcclxuICAgIHZhciBhbmltYXRpb25TcGVlZCA9IGlzWm9vbUluXHJcbiAgICAgICAgPyB6b29tSW4uYW5pbWF0aW9uVGltZVxyXG4gICAgICAgIDogem9vbU91dC5hbmltYXRpb25UaW1lO1xyXG4gICAgdmFyIGFuaW1hdGlvblR5cGUgPSBpc1pvb21JbiA/IHpvb21Jbi5hbmltYXRpb25UeXBlIDogem9vbU91dC5hbmltYXRpb25UeXBlO1xyXG4gICAgdmFyIGlzRGlzYWJsZWQgPSBpc1pvb21JbiA/IHpvb21Jbi5kaXNhYmxlZCA6IHpvb21PdXQuZGlzYWJsZWQ7XHJcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSBoYW5kbGVab29tVG9Qb2ludC5jYWxsKHRoaXMsIGlzRGlzYWJsZWQsIG5ld1NjYWxlLCBtb3VzZVgsIG1vdXNlWSk7XHJcbiAgICBpZiAodGFyZ2V0U3RhdGUuc2NhbGUgPT09IHNjYWxlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciB0YXJnZXRTY2FsZSA9IGhhbmRsZUNhbGN1bGF0ZVpvb20uY2FsbCh0aGlzLCBjdXN0b21EZWx0YSwgY3VzdG9tU3RlcCwgdHJ1ZSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIHZhciB0aW1lID0gZ2V0QnV0dG9uQW5pbWF0aW9uVGltZSh0YXJnZXRTY2FsZSwgbmV3U2NhbGUsIGFuaW1hdGlvblNwZWVkKTtcclxuICAgIGFuaW1hdGVDb21wb25lbnQuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgdGFyZ2V0U3RhdGU6IHRhcmdldFN0YXRlLFxyXG4gICAgICAgIHNwZWVkOiB0aW1lLFxyXG4gICAgICAgIHR5cGU6IGFuaW1hdGlvblR5cGUsXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXNldFRyYW5zZm9ybWF0aW9ucyhhbmltYXRpb25TcGVlZCkge1xyXG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVzLCBkZWZhdWx0U2NhbGUgPSBfYS5kZWZhdWx0U2NhbGUsIGRlZmF1bHRQb3NpdGlvblggPSBfYS5kZWZhdWx0UG9zaXRpb25YLCBkZWZhdWx0UG9zaXRpb25ZID0gX2EuZGVmYXVsdFBvc2l0aW9uWTtcclxuICAgIHZhciBfYiA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYi5zY2FsZSwgcG9zaXRpb25YID0gX2IucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYi5wb3NpdGlvblksIHJlc2V0ID0gX2IucmVzZXQsIF9jID0gX2Iub3B0aW9ucywgZGlzYWJsZWQgPSBfYy5kaXNhYmxlZCwgbGltaXRUb0JvdW5kcyA9IF9jLmxpbWl0VG9Cb3VuZHMsIGNlbnRlckNvbnRlbnQgPSBfYy5jZW50ZXJDb250ZW50LCBsaW1pdFRvV3JhcHBlciA9IF9jLmxpbWl0VG9XcmFwcGVyO1xyXG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2V0LmRpc2FibGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlmIChzY2FsZSA9PT0gZGVmYXVsdFNjYWxlICYmXHJcbiAgICAgICAgcG9zaXRpb25YID09PSBkZWZhdWx0UG9zaXRpb25YICYmXHJcbiAgICAgICAgcG9zaXRpb25ZID09PSBkZWZhdWx0UG9zaXRpb25ZKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBzcGVlZCA9IHR5cGVvZiBhbmltYXRpb25TcGVlZCA9PT0gXCJudW1iZXJcIiA/IGFuaW1hdGlvblNwZWVkIDogcmVzZXQuYW5pbWF0aW9uVGltZTtcclxuICAgIHZhciB0YXJnZXRTY2FsZSA9IGNoZWNrSXNOdW1iZXIoZGVmYXVsdFNjYWxlLCBpbml0aWFsU3RhdGUuc2NhbGUpO1xyXG4gICAgdmFyIG5ld1Bvc2l0aW9uWCA9IGNoZWNrSXNOdW1iZXIoZGVmYXVsdFBvc2l0aW9uWCwgaW5pdGlhbFN0YXRlLnBvc2l0aW9uWCk7XHJcbiAgICB2YXIgbmV3UG9zaXRpb25ZID0gY2hlY2tJc051bWJlcihkZWZhdWx0UG9zaXRpb25ZLCBpbml0aWFsU3RhdGUucG9zaXRpb25ZKTtcclxuICAgIGlmICgobGltaXRUb0JvdW5kcyAmJiAhbGltaXRUb1dyYXBwZXIpIHx8IGNlbnRlckNvbnRlbnQpIHtcclxuICAgICAgICB2YXIgYm91bmRzID0gaGFuZGxlQ2FsY3VsYXRlQm91bmRzLmNhbGwodGhpcywgdGFyZ2V0U2NhbGUsIGxpbWl0VG9XcmFwcGVyKTtcclxuICAgICAgICBuZXdQb3NpdGlvblggPSBib3VuZHMubWluUG9zaXRpb25YO1xyXG4gICAgICAgIG5ld1Bvc2l0aW9uWSA9IGJvdW5kcy5taW5Qb3NpdGlvblk7XHJcbiAgICB9XHJcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSB7XHJcbiAgICAgICAgc2NhbGU6IHRhcmdldFNjYWxlLFxyXG4gICAgICAgIHBvc2l0aW9uWDogbmV3UG9zaXRpb25YLFxyXG4gICAgICAgIHBvc2l0aW9uWTogbmV3UG9zaXRpb25ZLFxyXG4gICAgfTtcclxuICAgIGFuaW1hdGVDb21wb25lbnQuY2FsbCh0aGlzLCB7XHJcbiAgICAgICAgdGFyZ2V0U3RhdGU6IHRhcmdldFN0YXRlLFxyXG4gICAgICAgIHNwZWVkOiBzcGVlZCxcclxuICAgICAgICB0eXBlOiByZXNldC5hbmltYXRpb25UeXBlLFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QnV0dG9uQW5pbWF0aW9uVGltZSh0YXJnZXRTY2FsZSwgbmV3U2NhbGUsIHRpbWUpIHtcclxuICAgIHJldHVybiB0aW1lICogKG5ld1NjYWxlIC8gdGFyZ2V0U2NhbGUpO1xyXG59XG5cbmZ1bmN0aW9uIHJvdW5kKG51bWJlciwgZGVjaW1hbCkge1xyXG4gICAgdmFyIHJvdW5kTnVtYmVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWwpO1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogcm91bmROdW1iZXIpIC8gcm91bmROdW1iZXI7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudERpc3RhbmNlKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UoZXZlbnQudG91Y2hlc1swXSwgZXZlbnQudG91Y2hlc1sxXSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tJZkluZmluaXRlKG51bWJlcikge1xyXG4gICAgcmV0dXJuIG51bWJlciA9PT0gSW5maW5pdHkgfHwgbnVtYmVyID09PSAtSW5maW5pdHk7XHJcbn1cclxuZnVuY3Rpb24gY2FsY3VsYXRlUGluY2hab29tKGN1cnJlbnREaXN0YW5jZSwgcGluY2hTdGFydERpc3RhbmNlKSB7XHJcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlUHJvdmlkZXIsIF9iID0gX2Eub3B0aW9ucywgbWluU2NhbGUgPSBfYi5taW5TY2FsZSwgbWF4U2NhbGUgPSBfYi5tYXhTY2FsZSwgX2MgPSBfYS5zY2FsZVBhZGRpbmcsIHNpemUgPSBfYy5zaXplLCBkaXNhYmxlZCA9IF9jLmRpc2FibGVkO1xyXG4gICAgaWYgKHR5cGVvZiBwaW5jaFN0YXJ0RGlzdGFuY2UgIT09IFwibnVtYmVyXCIgfHxcclxuICAgICAgICB0eXBlb2YgY3VycmVudERpc3RhbmNlICE9PSBcIm51bWJlclwiKVxyXG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiUGluY2ggdG91Y2hlcyBkaXN0YW5jZSB3YXMgbm90IHByb3ZpZGVkXCIpO1xyXG4gICAgaWYgKGN1cnJlbnREaXN0YW5jZSA8IDApXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHRvdWNoUHJvcG9ydGlvbiA9IGN1cnJlbnREaXN0YW5jZSAvIHBpbmNoU3RhcnREaXN0YW5jZTtcclxuICAgIHZhciBzY2FsZURpZmZlcmVuY2UgPSB0b3VjaFByb3BvcnRpb24gKiB0aGlzLnBpbmNoU3RhcnRTY2FsZTtcclxuICAgIHJldHVybiBjaGVja1pvb21Cb3VuZHMocm91bmROdW1iZXIoc2NhbGVEaWZmZXJlbmNlLCAyKSwgbWluU2NhbGUsIG1heFNjYWxlLCBzaXplLCAhZGlzYWJsZWQpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1pZHBvaW50KGV2ZW50LCBzY2FsZSwgY29udGVudENvbXBvbmVudCkge1xyXG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudENvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcclxuICAgIHZhciBmaXJzdFBvaW50WCA9IHJvdW5kKHRvdWNoZXNbMF0uY2xpZW50WCAtIGNvbnRlbnRSZWN0LmxlZnQsIDUpO1xyXG4gICAgdmFyIGZpcnN0UG9pbnRZID0gcm91bmQodG91Y2hlc1swXS5jbGllbnRZIC0gY29udGVudFJlY3QudG9wLCA1KTtcclxuICAgIHZhciBzZWNvbmRQb2ludFggPSByb3VuZCh0b3VjaGVzWzFdLmNsaWVudFggLSBjb250ZW50UmVjdC5sZWZ0LCA1KTtcclxuICAgIHZhciBzZWNvbmRQb2ludFkgPSByb3VuZCh0b3VjaGVzWzFdLmNsaWVudFkgLSBjb250ZW50UmVjdC50b3AsIDUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtb3VzZVg6IChmaXJzdFBvaW50WCArIHNlY29uZFBvaW50WCkgLyAyIC8gc2NhbGUsXHJcbiAgICAgICAgbW91c2VZOiAoZmlyc3RQb2ludFkgKyBzZWNvbmRQb2ludFkpIC8gMiAvIHNjYWxlLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVab29tUGluY2goZXZlbnQpIHtcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgc2NhbGUgPSBfYS5zY2FsZSwgX2IgPSBfYS5vcHRpb25zLCBsaW1pdFRvQm91bmRzID0gX2IubGltaXRUb0JvdW5kcywgbGltaXRUb1dyYXBwZXIgPSBfYi5saW1pdFRvV3JhcHBlciwgX2MgPSBfYS5zY2FsZVBhZGRpbmcsIGRpc2FibGVkID0gX2MuZGlzYWJsZWQsIHNpemUgPSBfYy5zaXplLCBsaW1pdHNPbldoZWVsID0gX2Eud2hlZWwubGltaXRzT25XaGVlbCwgcGluY2ggPSBfYS5waW5jaDtcclxuICAgIHZhciBjb250ZW50Q29tcG9uZW50ID0gdGhpcy5zdGF0ZS5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgaWYgKHBpbmNoLmRpc2FibGVkIHx8IHRoaXMuc3RhdGVQcm92aWRlci5vcHRpb25zLmRpc2FibGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH1cclxuICAgIC8vIGlmIG9uZSBmaW5nZXIgc3RhcnRzIGZyb20gb3V0c2lkZSBvZiB3cmFwcGVyXHJcbiAgICBpZiAodGhpcy5waW5jaFN0YXJ0RGlzdGFuY2UgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gUG9zaXRpb24gdHJhbnNmb3JtYXRpb25cclxuICAgIHZhciBfZCA9IGNhbGN1bGF0ZU1pZHBvaW50KGV2ZW50LCBzY2FsZSwgY29udGVudENvbXBvbmVudCksIG1vdXNlWCA9IF9kLm1vdXNlWCwgbW91c2VZID0gX2QubW91c2VZO1xyXG4gICAgLy8gaWYgdG91Y2hlcyBnb2VzIG9mZiBvZiB0aGUgd3JhcHBlciBlbGVtZW50XHJcbiAgICBpZiAoY2hlY2tJZkluZmluaXRlKG1vdXNlWCkgfHwgY2hlY2tJZkluZmluaXRlKG1vdXNlWSkpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IGdldEN1cnJlbnREaXN0YW5jZShldmVudCk7XHJcbiAgICB2YXIgbmV3U2NhbGUgPSBjYWxjdWxhdGVQaW5jaFpvb20uY2FsbCh0aGlzLCBjdXJyZW50RGlzdGFuY2UsIHRoaXMucGluY2hTdGFydERpc3RhbmNlKTtcclxuICAgIGlmIChjaGVja0lmSW5maW5pdGUobmV3U2NhbGUpIHx8IG5ld1NjYWxlID09PSBzY2FsZSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBHZXQgbmV3IGVsZW1lbnQgc2l6ZXMgdG8gY2FsY3VsYXRlIGJvdW5kc1xyXG4gICAgdmFyIGJvdW5kcyA9IGhhbmRsZUNhbGN1bGF0ZUJvdW5kcy5jYWxsKHRoaXMsIG5ld1NjYWxlLCBsaW1pdFRvV3JhcHBlcik7XHJcbiAgICAvLyBDYWxjdWxhdGUgdHJhbnNmb3JtYXRpb25zXHJcbiAgICB2YXIgaXNMaW1pdGVkVG9Cb3VuZHMgPSBsaW1pdFRvQm91bmRzICYmIChkaXNhYmxlZCB8fCBzaXplID09PSAwIHx8IGxpbWl0c09uV2hlZWwpO1xyXG4gICAgdmFyIF9lID0gaGFuZGxlQ2FsY3VsYXRlUG9zaXRpb25zLmNhbGwodGhpcywgbW91c2VYLCBtb3VzZVksIG5ld1NjYWxlLCBib3VuZHMsIGlzTGltaXRlZFRvQm91bmRzKSwgeCA9IF9lLngsIHkgPSBfZS55O1xyXG4gICAgdGhpcy5sYXN0RGlzdGFuY2UgPSBjdXJyZW50RGlzdGFuY2U7XHJcbiAgICB0aGlzLnN0YXRlUHJvdmlkZXIucG9zaXRpb25YID0geDtcclxuICAgIHRoaXMuc3RhdGVQcm92aWRlci5wb3NpdGlvblkgPSB5O1xyXG4gICAgdGhpcy5zdGF0ZVByb3ZpZGVyLnNjYWxlID0gbmV3U2NhbGU7XHJcbiAgICB0aGlzLnN0YXRlUHJvdmlkZXIucHJldmlvdXNTY2FsZSA9IHNjYWxlO1xyXG4gICAgLy8gdXBkYXRlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XHJcbn1cblxudmFyIHRocm90dGxlVGltZSA9IDMwO1xyXG5mdW5jdGlvbiB2ZWxvY2l0eVRpbWVTcGVlZChzcGVlZCwgYW5pbWF0aW9uVGltZSkge1xyXG4gICAgdmFyIHZlbG9jaXR5RXF1YWxUb01vdmUgPSB0aGlzLnN0YXRlUHJvdmlkZXIucGFuLnZlbG9jaXR5RXF1YWxUb01vdmU7XHJcbiAgICBpZiAodmVsb2NpdHlFcXVhbFRvTW92ZSkge1xyXG4gICAgICAgIHJldHVybiBhbmltYXRpb25UaW1lIC0gYW5pbWF0aW9uVGltZSAvIE1hdGgubWF4KDEsIHNwZWVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhbmltYXRpb25UaW1lO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVuYWJsZVZlbG9jaXR5KCkge1xyXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHN0YXJ0QW5pbWF0aW9uOiBmYWxzZSB9KTtcclxufVxyXG5mdW5jdGlvbiBoYW5kbGVGaXJlVmVsb2NpdHkoKSB7XHJcbiAgICB0aGlzLnNldFN0YXRlKHsgc3RhcnRBbmltYXRpb246IHRydWUgfSk7XHJcbn1cclxuZnVuY3Rpb24gYW5pbWF0ZVZlbG9jaXR5KCkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciBfYSA9IHRoaXMuc3RhdGVQcm92aWRlciwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblksIGxpbWl0VG9Cb3VuZHMgPSBfYS5vcHRpb25zLmxpbWl0VG9Cb3VuZHMsIF9iID0gX2EucGFuLCB2ZWxvY2l0eUJhc2VUaW1lID0gX2IudmVsb2NpdHlCYXNlVGltZSwgbG9ja0F4aXNYID0gX2IubG9ja0F4aXNYLCBsb2NrQXhpc1kgPSBfYi5sb2NrQXhpc1ksIHZlbG9jaXR5QW5pbWF0aW9uVHlwZSA9IF9iLnZlbG9jaXR5QW5pbWF0aW9uVHlwZSwgcGFuUmV0dXJuQW5pbWF0aW9uVGltZSA9IF9iLnBhblJldHVybkFuaW1hdGlvblRpbWUsIHBhblJldHVybkFuaW1hdGlvblR5cGUgPSBfYi5wYW5SZXR1cm5BbmltYXRpb25UeXBlLCBwYWRkaW5nID0gX2IucGFkZGluZywgcGFkZGluZ1NpemUgPSBfYi5wYWRkaW5nU2l6ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9hLndyYXBwZXJDb21wb25lbnQ7XHJcbiAgICBpZiAoIXRoaXMubW91bnRlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAoIXRoaXMudmVsb2NpdHkgfHwgIXRoaXMuYm91bmRzKVxyXG4gICAgICAgIHJldHVybiBoYW5kbGVEaXNhYmxlQW5pbWF0aW9uLmNhbGwodGhpcyk7XHJcbiAgICB2YXIgX2MgPSB0aGlzLmJvdW5kcywgbWF4UG9zaXRpb25YID0gX2MubWF4UG9zaXRpb25YLCBtaW5Qb3NpdGlvblggPSBfYy5taW5Qb3NpdGlvblgsIG1heFBvc2l0aW9uWSA9IF9jLm1heFBvc2l0aW9uWSwgbWluUG9zaXRpb25ZID0gX2MubWluUG9zaXRpb25ZO1xyXG4gICAgdmFyIF9kID0gdGhpcy52ZWxvY2l0eSwgdmVsb2NpdHlYID0gX2QudmVsb2NpdHlYLCB2ZWxvY2l0eVkgPSBfZC52ZWxvY2l0eVksIHZlbG9jaXR5ID0gX2QudmVsb2NpdHk7XHJcbiAgICB2YXIgYW5pbWF0aW9uVGltZSA9IHZlbG9jaXR5VGltZVNwZWVkLmNhbGwodGhpcywgdmVsb2NpdHksIHZlbG9jaXR5QmFzZVRpbWUpO1xyXG4gICAgaWYgKCFhbmltYXRpb25UaW1lKSB7XHJcbiAgICAgICAgaGFuZGxlUGFubmluZ0FuaW1hdGlvbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciB0YXJnZXRYID0gdmVsb2NpdHlYO1xyXG4gICAgdmFyIHRhcmdldFkgPSB2ZWxvY2l0eVk7XHJcbiAgICAvLyBwYW4gcmV0dXJuIGFuaW1hdGlvblxyXG4gICAgdmFyIG5ld0FuaW1hdGlvblRpbWUgPSBhbmltYXRpb25UaW1lID4gcGFuUmV0dXJuQW5pbWF0aW9uVGltZVxyXG4gICAgICAgID8gYW5pbWF0aW9uVGltZVxyXG4gICAgICAgIDogcGFuUmV0dXJuQW5pbWF0aW9uVGltZTtcclxuICAgIHZhciBwYWRkaW5nVmFsdWUgPSBwYWRkaW5nID8gcGFkZGluZ1NpemUgOiAwO1xyXG4gICAgdmFyIHBhZGRpbmdYID0gd3JhcHBlckNvbXBvbmVudFxyXG4gICAgICAgID8gKHBhZGRpbmdWYWx1ZSAqIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGgpIC8gMTAwXHJcbiAgICAgICAgOiAwO1xyXG4gICAgdmFyIHBhZGRpbmdZID0gd3JhcHBlckNvbXBvbmVudFxyXG4gICAgICAgID8gKHBhZGRpbmdWYWx1ZSAqIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0KSAvIDEwMFxyXG4gICAgICAgIDogMDtcclxuICAgIHZhciBtYXhUYXJnZXRYID0gbWF4UG9zaXRpb25YICsgcGFkZGluZ1g7XHJcbiAgICB2YXIgbWluVGFyZ2V0WCA9IG1pblBvc2l0aW9uWCAtIHBhZGRpbmdYO1xyXG4gICAgdmFyIG1heFRhcmdldFkgPSBtYXhQb3NpdGlvblkgKyBwYWRkaW5nWTtcclxuICAgIHZhciBtaW5UYXJnZXRZID0gbWluUG9zaXRpb25ZIC0gcGFkZGluZ1k7XHJcbiAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IGNoZWNrUG9zaXRpb25Cb3VuZHMocG9zaXRpb25YLCBwb3NpdGlvblksIHRoaXMuYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWUsIHdyYXBwZXJDb21wb25lbnQpO1xyXG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgLy8gYW5pbWF0aW9uIHN0YXJ0IHRpbWVzdGFtcFxyXG4gICAgYW5pbWF0ZS5jYWxsKHRoaXMsIHZlbG9jaXR5QW5pbWF0aW9uVHlwZSwgbmV3QW5pbWF0aW9uVGltZSwgZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICB2YXIgZnJhbWVUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XHJcbiAgICAgICAgdmFyIGFuaW1hdGlvblByb2dyZXNzID0gZnJhbWVUaW1lIC8gcGFuUmV0dXJuQW5pbWF0aW9uVGltZTtcclxuICAgICAgICB2YXIgcmV0dXJuQW5pbWF0aW9uID0gYXZhaWxhYmxlQW5pbWF0aW9uc1twYW5SZXR1cm5BbmltYXRpb25UeXBlXTtcclxuICAgICAgICB2YXIgY3VzdG9tUmV0dXJuU3RlcCA9IHJldHVybkFuaW1hdGlvbihhbmltYXRpb25Qcm9ncmVzcyk7XHJcbiAgICAgICAgaWYgKGZyYW1lVGltZSA+IHBhblJldHVybkFuaW1hdGlvblRpbWUgfHxcclxuICAgICAgICAgICAgY3VzdG9tUmV0dXJuU3RlcCA+IDEgfHxcclxuICAgICAgICAgICAgY3VzdG9tUmV0dXJuU3RlcCA9PT0gSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgY3VzdG9tUmV0dXJuU3RlcCA9PT0gLUluZmluaXR5KVxyXG4gICAgICAgICAgICBjdXN0b21SZXR1cm5TdGVwID0gMTtcclxuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uWCA9IGdldFBvc2l0aW9uKGxvY2tBeGlzWCwgdGFyZ2V0WCwgc3RlcCwgY3VzdG9tUmV0dXJuU3RlcCwgbWluUG9zaXRpb25YLCBtYXhQb3NpdGlvblgsIGxpbWl0VG9Cb3VuZHMsIHBvc2l0aW9uWCwgc3RhcnRQb3NpdGlvbi54LCBtaW5UYXJnZXRYLCBtYXhUYXJnZXRYKTtcclxuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uWSA9IGdldFBvc2l0aW9uKGxvY2tBeGlzWSwgdGFyZ2V0WSwgc3RlcCwgY3VzdG9tUmV0dXJuU3RlcCwgbWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblksIGxpbWl0VG9Cb3VuZHMsIHBvc2l0aW9uWSwgc3RhcnRQb3NpdGlvbi55LCBtaW5UYXJnZXRZLCBtYXhUYXJnZXRZKTtcclxuICAgICAgICBpZiAocG9zaXRpb25YICE9PSBjdXJyZW50UG9zaXRpb25YIHx8IHBvc2l0aW9uWSAhPT0gY3VycmVudFBvc2l0aW9uWSkge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHBhbm5lZCBwb3NpdGlvblxyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyLnBvc2l0aW9uWCA9IGN1cnJlbnRQb3NpdGlvblg7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YXRlUHJvdmlkZXIucG9zaXRpb25ZID0gY3VycmVudFBvc2l0aW9uWTtcclxuICAgICAgICAgICAgLy8gYXBwbHkgYW5pbWF0aW9uIGNoYW5nZXNcclxuICAgICAgICAgICAgX3RoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVZlbG9jaXR5U3RhcnQoZXZlbnQpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgX2EgPSB0aGlzLnN0YXRlUHJvdmlkZXIsIHNjYWxlID0gX2Euc2NhbGUsIGRpc2FibGVkID0gX2Eub3B0aW9ucy5kaXNhYmxlZCwgX2IgPSBfYS5wYW4sIHZlbG9jaXR5ID0gX2IudmVsb2NpdHksIHZlbG9jaXR5U2Vuc2l0aXZpdHkgPSBfYi52ZWxvY2l0eVNlbnNpdGl2aXR5LCB2ZWxvY2l0eUFjdGl2ZVNjYWxlID0gX2IudmVsb2NpdHlBY3RpdmVTY2FsZSwgdmVsb2NpdHlNaW5TcGVlZCA9IF9iLnZlbG9jaXR5TWluU3BlZWQsIHdyYXBwZXJDb21wb25lbnQgPSBfYS53cmFwcGVyQ29tcG9uZW50O1xyXG4gICAgaWYgKCF2ZWxvY2l0eSB8fCB2ZWxvY2l0eUFjdGl2ZVNjYWxlID49IHNjYWxlIHx8IGRpc2FibGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGhhbmRsZUVuYWJsZVZlbG9jaXR5LmNhbGwodGhpcyk7XHJcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGlmICh0aGlzLmxhc3RNb3VzZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uXzEgPSBnZXRDbGllbnRQb3NpdGlvbihldmVudCk7XHJcbiAgICAgICAgaWYgKCFwb3NpdGlvbl8xKVxyXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIk5vIG1vdXNlIG9yIHRvdWNoIHBvc2l0aW9uIGRldGVjdGVkXCIpO1xyXG4gICAgICAgIHZhciBjbGllbnRYID0gcG9zaXRpb25fMS5jbGllbnRYLCBjbGllbnRZID0gcG9zaXRpb25fMS5jbGllbnRZO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZVggPSBjbGllbnRYIC0gdGhpcy5sYXN0TW91c2VQb3NpdGlvbi5jbGllbnRYO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZVkgPSBjbGllbnRZIC0gdGhpcy5sYXN0TW91c2VQb3NpdGlvbi5jbGllbnRZO1xyXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5vdyAtIHRoaXMudmVsb2NpdHlUaW1lO1xyXG4gICAgICAgIHZhciB3cmFwcGVyVG9XaW5kb3dTY2FsZVggPSAyIC0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aCAvIHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgIHZhciB3cmFwcGVyVG9XaW5kb3dTY2FsZVkgPSAyIC0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQgLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNjYWxlZFggPSAyMCAqIE1hdGgubWF4KHZlbG9jaXR5TWluU3BlZWQsIE1hdGgubWluKDIsIHdyYXBwZXJUb1dpbmRvd1NjYWxlWCkpO1xyXG4gICAgICAgIHZhciBzY2FsZWRZID0gMjAgKiBNYXRoLm1heCh2ZWxvY2l0eU1pblNwZWVkLCBNYXRoLm1pbigyLCB3cmFwcGVyVG9XaW5kb3dTY2FsZVkpKTtcclxuICAgICAgICB2YXIgdmVsb2NpdHlYID0gKGRpc3RhbmNlWCAvIGludGVydmFsKSAqIHZlbG9jaXR5U2Vuc2l0aXZpdHkgKiBzY2FsZSAqIHNjYWxlZFg7XHJcbiAgICAgICAgdmFyIHZlbG9jaXR5WSA9IChkaXN0YW5jZVkgLyBpbnRlcnZhbCkgKiB2ZWxvY2l0eVNlbnNpdGl2aXR5ICogc2NhbGUgKiBzY2FsZWRZO1xyXG4gICAgICAgIHZhciBzcGVlZCA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcclxuICAgICAgICB2YXIgdmVsb2NpdHlfMSA9IChNYXRoLnNxcnQoc3BlZWQpIC8gaW50ZXJ2YWwpICogdmVsb2NpdHlTZW5zaXRpdml0eTtcclxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eSAmJiB2ZWxvY2l0eV8xIDwgdGhpcy52ZWxvY2l0eS52ZWxvY2l0eSAmJiB0aGlzLnRocm90dGxlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHsgdmVsb2NpdHlYOiB2ZWxvY2l0eVgsIHZlbG9jaXR5WTogdmVsb2NpdHlZLCB2ZWxvY2l0eTogdmVsb2NpdHlfMSB9O1xyXG4gICAgICAgIC8vIHRocm90dGxpbmdcclxuICAgICAgICBpZiAodGhpcy50aHJvdHRsZSlcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGhyb3R0bGUpO1xyXG4gICAgICAgIHRoaXMudGhyb3R0bGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm1vdW50ZWQpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy50aHJvdHRsZSA9IGZhbHNlO1xyXG4gICAgICAgIH0sIHRocm90dGxlVGltZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRDbGllbnRQb3NpdGlvbihldmVudCk7XHJcbiAgICB0aGlzLmxhc3RNb3VzZVBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG5vdztcclxufVxyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihpc0xvY2tlZCwgdGFyZ2V0LCBzdGVwLCBwYW5SZXR1cm5TdGVwLCBtaW5Cb3VuZCwgbWF4Qm91bmQsIGxpbWl0VG9Cb3VuZHMsIG9mZnNldCwgc3RhcnRQb3NpdGlvbiwgbWluVGFyZ2V0LCBtYXhUYXJnZXQpIHtcclxuICAgIGlmIChsaW1pdFRvQm91bmRzKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPiBtaW5Cb3VuZCAmJiBvZmZzZXQgPiBtYXhCb3VuZCkge1xyXG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uIC0gKHN0YXJ0UG9zaXRpb24gLSBtYXhCb3VuZCkgKiBwYW5SZXR1cm5TdGVwO1xyXG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb24gPiBtYXhUYXJnZXQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4VGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb24gPCBtYXhCb3VuZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXhCb3VuZDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Bvc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IG1pbkJvdW5kICYmIG9mZnNldCA8IG1pbkJvdW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gLSAoc3RhcnRQb3NpdGlvbiAtIG1pbkJvdW5kKSAqIHBhblJldHVyblN0ZXA7XHJcbiAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiA8IG1pblRhcmdldClcclxuICAgICAgICAgICAgICAgIHJldHVybiBtaW5UYXJnZXQ7XHJcbiAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiA+IG1pbkJvdW5kKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pbkJvdW5kO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3UG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzTG9ja2VkKVxyXG4gICAgICAgIHJldHVybiBzdGFydFBvc2l0aW9uO1xyXG4gICAgdmFyIG9mZnNldFBvc2l0aW9uID0gb2Zmc2V0ICsgdGFyZ2V0ICogc3RlcDtcclxuICAgIHJldHVybiBib3VuZExpbWl0ZXIob2Zmc2V0UG9zaXRpb24sIG1pbkJvdW5kLCBtYXhCb3VuZCwgbGltaXRUb0JvdW5kcyk7XHJcbn1cblxuLy8gV2Ugd2FudCB0byBtYWtlIGV2ZW50IGxpc3RlbmVycyBub24tcGFzc2l2ZSwgYW5kIHRvIGRvIHNvIGhhdmUgdG8gY2hlY2tcclxuZnVuY3Rpb24gbWFrZVBhc3NpdmVFdmVudE9wdGlvbihwYXNzaXZlKSB7XHJcbiAgICByZXR1cm4gIHBhc3NpdmU7XHJcbn1cblxudmFyIHByb3BzTGlzdCA9IFtcclxuICAgIFwicHJldmlvdXNTY2FsZVwiLFxyXG4gICAgXCJzY2FsZVwiLFxyXG4gICAgXCJwb3NpdGlvblhcIixcclxuICAgIFwicG9zaXRpb25ZXCIsXHJcbiAgICBcImRlZmF1bHRQb3NpdGlvblhcIixcclxuICAgIFwiZGVmYXVsdFBvc2l0aW9uWVwiLFxyXG4gICAgXCJkZWZhdWx0U2NhbGVcIixcclxuICAgIFwib25XaGVlbFN0YXJ0XCIsXHJcbiAgICBcIm9uV2hlZWxcIixcclxuICAgIFwib25XaGVlbFN0b3BcIixcclxuICAgIFwib25QYW5uaW5nU3RhcnRcIixcclxuICAgIFwib25QYW5uaW5nXCIsXHJcbiAgICBcIm9uUGFubmluZ1N0b3BcIixcclxuICAgIFwib25QaW5jaGluZ1N0YXJ0XCIsXHJcbiAgICBcIm9uUGluY2hpbmdcIixcclxuICAgIFwib25QaW5jaGluZ1N0b3BcIixcclxuICAgIFwib25ab29tQ2hhbmdlXCIsXHJcbiAgICBcIm9wdGlvbnNcIixcclxuICAgIFwid2hlZWxcIixcclxuICAgIFwic2NhbGVQYWRkaW5nXCIsXHJcbiAgICBcInBhblwiLFxyXG4gICAgXCJwaW5jaFwiLFxyXG4gICAgXCJ6b29tSW5cIixcclxuICAgIFwiem9vbU91dFwiLFxyXG4gICAgXCJkb3VibGVDbGlja1wiLFxyXG4gICAgXCJyZXNldFwiLFxyXG5dO1xyXG52YXIgZ2V0VmFsaWRQcm9wc0Zyb21PYmplY3QgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xyXG4gICAgICAgIGlmIChwcm9wc0xpc3QuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICBhY2Nba2V5XSA9IHByb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSk7XHJcbn07XG5cbnZhciBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XHJcbnZhciB3aGVlbFN0b3BFdmVudFRpbWVyID0gbnVsbDtcclxudmFyIHdoZWVsU3RvcEV2ZW50VGltZSA9IDE4MDtcclxudmFyIHdoZWVsQW5pbWF0aW9uVGltZXIgPSBudWxsO1xyXG52YXIgd2hlZWxBbmltYXRpb25UaW1lID0gMTAwO1xyXG52YXIgU3RhdGVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdGF0ZVByb3ZpZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RhdGVQcm92aWRlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgd3JhcHBlckNvbXBvbmVudDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb250ZW50Q29tcG9uZW50OiB1bmRlZmluZWQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSksIG1lcmdlUHJvcHMoaW5pdGlhbFN0YXRlLCBfdGhpcy5wcm9wcy5keW5hbWljVmFsdWVzKSksIF90aGlzLnByb3BzLmRlZmF1bHRWYWx1ZXMpLCB7IHByZXZpb3VzU2NhbGU6IF90aGlzLnByb3BzLmR5bmFtaWNWYWx1ZXMuc2NhbGUgfHxcclxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmRlZmF1bHRWYWx1ZXMuc2NhbGUgfHxcclxuICAgICAgICAgICAgICAgIGluaXRpYWxTdGF0ZS5zY2FsZSB9KTtcclxuICAgICAgICBfdGhpcy53aW5kb3dUb1dyYXBwZXJTY2FsZVggPSAwO1xyXG4gICAgICAgIF90aGlzLndpbmRvd1RvV3JhcHBlclNjYWxlWSA9IDA7XHJcbiAgICAgICAgLy8gcGFubmluZyBoZWxwZXJzXHJcbiAgICAgICAgX3RoaXMuc3RhcnRDb29yZHMgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLmlzRG93biA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHBpbmNoIGhlbHBlcnNcclxuICAgICAgICBfdGhpcy5waW5jaFN0YXJ0RGlzdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLmxhc3REaXN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMucGluY2hTdGFydFNjYWxlID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5kaXN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuYm91bmRzID0gbnVsbDtcclxuICAgICAgICAvLyB2ZWxvY2l0eSBoZWxwZXJzXHJcbiAgICAgICAgX3RoaXMudmVsb2NpdHlUaW1lID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5sYXN0TW91c2VQb3NpdGlvbiA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMudmVsb2NpdHkgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLm9mZnNldFggPSBudWxsO1xyXG4gICAgICAgIF90aGlzLm9mZnNldFkgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLnRocm90dGxlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gd2hlZWwgaGVscGVyc1xyXG4gICAgICAgIF90aGlzLnByZXZpb3VzV2hlZWxFdmVudCA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMubGFzdFNjYWxlID0gbnVsbDtcclxuICAgICAgICAvLyBhbmltYXRpb25zIGhlbHBlcnNcclxuICAgICAgICBfdGhpcy5hbmltYXRlID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgIF90aGlzLm1heEJvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIC8vIFdoZWVsXHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVdoZWVsID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHNjYWxlID0gX2Euc2NhbGUsIF9iID0gX2Eud2hlZWwsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIHdoZWVsRW5hYmxlZCA9IF9iLndoZWVsRW5hYmxlZCwgdG91Y2hQYWRFbmFibGVkID0gX2IudG91Y2hQYWRFbmFibGVkO1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5wcm9wcywgb25XaGVlbFN0YXJ0ID0gX2Mub25XaGVlbFN0YXJ0LCBvbldoZWVsID0gX2Mub25XaGVlbCwgb25XaGVlbFN0b3AgPSBfYy5vbldoZWVsU3RvcDtcclxuICAgICAgICAgICAgdmFyIF9kID0gX3RoaXMuc3RhdGUsIHdyYXBwZXJDb21wb25lbnQgPSBfZC53cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50ID0gX2QuY29udGVudENvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmlzRG93biB8fFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlUHJvdmlkZXIub3B0aW9ucy5kaXNhYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgIXdyYXBwZXJDb21wb25lbnQgfHxcclxuICAgICAgICAgICAgICAgICFjb250ZW50Q29tcG9uZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAvLyBjdHJsS2V5IGRldGVjdHMgaWYgdG91Y2hwYWQgZXhlY3V0ZSB3aGVlbCBvciBwaW5jaCBnZXN0dXJlXHJcbiAgICAgICAgICAgIGlmICghd2hlZWxFbmFibGVkICYmICFldmVudC5jdHJsS2V5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoIXRvdWNoUGFkRW5hYmxlZCAmJiBldmVudC5jdHJsS2V5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAvLyBXaGVlbCBzdGFydCBldmVudFxyXG4gICAgICAgICAgICBpZiAoIXdoZWVsU3RvcEV2ZW50VGltZXIpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RTY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRGlzYWJsZUFuaW1hdGlvbi5jYWxsKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKG9uV2hlZWxTdGFydCwgX3RoaXMuZ2V0Q2FsbGJhY2tQcm9wcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXaGVlbCBldmVudFxyXG4gICAgICAgICAgICBoYW5kbGVXaGVlbFpvb20uY2FsbChfdGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhvbldoZWVsLCBfdGhpcy5nZXRDYWxsYmFja1Byb3BzKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICBfdGhpcy5wcmV2aW91c1doZWVsRXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgLy8gV2hlZWwgc3RvcCBldmVudFxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlV2hlZWxTdG9wKF90aGlzLnByZXZpb3VzV2hlZWxFdmVudCwgZXZlbnQsIF90aGlzLnN0YXRlUHJvdmlkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2hlZWxTdG9wRXZlbnRUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB3aGVlbFN0b3BFdmVudFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5tb3VudGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2sob25XaGVlbFN0b3AsIF90aGlzLmdldENhbGxiYWNrUHJvcHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlZWxTdG9wRXZlbnRUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9LCB3aGVlbFN0b3BFdmVudFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNhbmNlbCBhbmltYXRpb25cclxuICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBmaXJlIGFuaW1hdGlvblxyXG4gICAgICAgICAgICBfdGhpcy5sYXN0U2NhbGUgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLnNjYWxlO1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQod2hlZWxBbmltYXRpb25UaW1lcik7XHJcbiAgICAgICAgICAgIHdoZWVsQW5pbWF0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMubW91bnRlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVQYWRkaW5nQW5pbWF0aW9uJDEuY2FsbChfdGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgICB9LCB3aGVlbEFuaW1hdGlvblRpbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIC8vIFBhbm5pbmdcclxuICAgICAgICAvLy8vLy8vLy8vXHJcbiAgICAgICAgX3RoaXMuY2hlY2tQYW5uaW5nVGFyZ2V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNhYmxlT25UYXJnZXQgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLnBhbi5kaXNhYmxlT25UYXJnZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiAoZGlzYWJsZU9uVGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZy50b1VwcGVyQ2FzZSgpOyB9KVxyXG4gICAgICAgICAgICAgICAgLmluY2x1ZGVzKGV2ZW50LnRhcmdldC50YWdOYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZU9uVGFyZ2V0LmZpbmQoZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5pbmNsdWRlcyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmNoZWNrSXNQYW5uaW5nQWN0aXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnN0YXRlUHJvdmlkZXIucGFuLmRpc2FibGVkO1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9hLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYS5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICByZXR1cm4gKCFfdGhpcy5pc0Rvd24gfHxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkIHx8XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyLm9wdGlvbnMuZGlzYWJsZWQgfHxcclxuICAgICAgICAgICAgICAgIChldmVudC50b3VjaGVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKF90aGlzLnN0YXJ0Q29vcmRzLnggLSBldmVudC50b3VjaGVzWzBdLmNsaWVudFgpIDwgMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhfdGhpcy5zdGFydENvb3Jkcy55IC0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRZKSA8IDEpKSB8fFxyXG4gICAgICAgICAgICAgICAgIXdyYXBwZXJDb21wb25lbnQgfHxcclxuICAgICAgICAgICAgICAgICFjb250ZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVNldFVwUGFubmluZyA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xyXG4gICAgICAgICAgICBfdGhpcy5pc0Rvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGFydENvb3JkcyA9IHsgeDogeCAtIHBvc2l0aW9uWCwgeTogeSAtIHBvc2l0aW9uWSB9O1xyXG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhfdGhpcy5wcm9wcy5vblBhbm5pbmdTdGFydCwgX3RoaXMuZ2V0Q2FsbGJhY2tQcm9wcygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVN0YXJ0UGFubmluZyA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLCB3cmFwcGVyQ29tcG9uZW50ID0gX2Eud3JhcHBlckNvbXBvbmVudCwgc2NhbGUgPSBfYS5zY2FsZSwgX2IgPSBfYS5vcHRpb25zLCBtaW5TY2FsZSA9IF9iLm1pblNjYWxlLCBtYXhTY2FsZSA9IF9iLm1heFNjYWxlLCBsaW1pdFRvV3JhcHBlciA9IF9iLmxpbWl0VG9XcmFwcGVyLCBkaXNhYmxlZCA9IF9hLnBhbi5kaXNhYmxlZDtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCwgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCB8fFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVQcm92aWRlci5vcHRpb25zLmRpc2FibGVkIHx8XHJcbiAgICAgICAgICAgICAgICAod3JhcHBlckNvbXBvbmVudCAmJiAhd3JhcHBlckNvbXBvbmVudC5jb250YWlucyh0YXJnZXQpKSB8fFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tQYW5uaW5nVGFyZ2V0KGV2ZW50KSB8fFxyXG4gICAgICAgICAgICAgICAgc2NhbGUgPCBtaW5TY2FsZSB8fFxyXG4gICAgICAgICAgICAgICAgc2NhbGUgPiBtYXhTY2FsZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaGFuZGxlRGlzYWJsZUFuaW1hdGlvbi5jYWxsKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuYm91bmRzID0gaGFuZGxlQ2FsY3VsYXRlQm91bmRzLmNhbGwoX3RoaXMsIHNjYWxlLCBsaW1pdFRvV3JhcHBlcik7XHJcbiAgICAgICAgICAgIC8vIE1vYmlsZSBwb2ludHNcclxuICAgICAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVNldFVwUGFubmluZyh0b3VjaGVzWzBdLmNsaWVudFgsIHRvdWNoZXNbMF0uY2xpZW50WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGVza3RvcCBwb2ludHNcclxuICAgICAgICAgICAgaWYgKCF0b3VjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTZXRVcFBhbm5pbmcoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVBhbm5pbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmlzRG93bilcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jaGVja0lzUGFubmluZ0FjdGl2ZShldmVudCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBjYWxjdWxhdGVWZWxvY2l0eVN0YXJ0LmNhbGwoX3RoaXMsIGV2ZW50KTtcclxuICAgICAgICAgICAgaGFuZGxlUGFubmluZy5jYWxsKF90aGlzLCBldmVudCk7XHJcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKF90aGlzLnByb3BzLm9uUGFubmluZywgX3RoaXMuZ2V0Q2FsbGJhY2tQcm9wcygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVN0b3BQYW5uaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEb3duKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0Rvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRmlyZVZlbG9jaXR5LmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soX3RoaXMucHJvcHMub25QYW5uaW5nU3RvcCwgX3RoaXMuZ2V0Q2FsbGJhY2tQcm9wcygpKTtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHZlbG9jaXR5ID0gX2EucGFuLnZlbG9jaXR5LCBzY2FsZSA9IF9hLnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgdmVsb2NpdHkgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudmVsb2NpdHkgJiYgdmVsb2NpdHkgJiYgc2NhbGUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVZlbG9jaXR5LmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBmaXQgdG8gYm91bmRzIGFuaW1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVBhbm5pbmdBbmltYXRpb24uY2FsbChfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vLy8vLy8vLy9cclxuICAgICAgICAvLyBQaW5jaFxyXG4gICAgICAgIC8vLy8vLy8vLy9cclxuICAgICAgICBfdGhpcy5oYW5kbGVQaW5jaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IF90aGlzLnN0YXRlUHJvdmlkZXIuc2NhbGU7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBoYW5kbGVEaXNhYmxlQW5pbWF0aW9uLmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBnZXREaXN0YW5jZShldmVudC50b3VjaGVzWzBdLCBldmVudC50b3VjaGVzWzFdKTtcclxuICAgICAgICAgICAgX3RoaXMucGluY2hTdGFydERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIF90aGlzLmxhc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICBfdGhpcy5waW5jaFN0YXJ0U2NhbGUgPSBzY2FsZTtcclxuICAgICAgICAgICAgX3RoaXMuaXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKF90aGlzLnByb3BzLm9uUGluY2hpbmdTdGFydCwgX3RoaXMuZ2V0Q2FsbGJhY2tQcm9wcygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVBpbmNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmlzRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICBoYW5kbGVab29tUGluY2guY2FsbChfdGhpcywgZXZlbnQpO1xyXG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhfdGhpcy5wcm9wcy5vblBpbmNoaW5nLCBfdGhpcy5nZXRDYWxsYmFja1Byb3BzKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuaGFuZGxlUGluY2hTdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnBpbmNoU3RhcnRTY2FsZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52ZWxvY2l0eSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0RGlzdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGluY2hTdGFydFNjYWxlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBpbmNoU3RhcnREaXN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVQYWRkaW5nQW5pbWF0aW9uJDEuY2FsbChfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhfdGhpcy5wcm9wcy5vblBpbmNoaW5nU3RvcCwgX3RoaXMuZ2V0Q2FsbGJhY2tQcm9wcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIC8vIFRvdWNoIEV2ZW50c1xyXG4gICAgICAgIC8vLy8vLy8vLy9cclxuICAgICAgICBfdGhpcy5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHdyYXBwZXJDb21wb25lbnQgPSBfYS53cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50ID0gX2EuY29udGVudENvbXBvbmVudCwgc2NhbGUgPSBfYS5zY2FsZSwgX2IgPSBfYS5vcHRpb25zLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBtaW5TY2FsZSA9IF9iLm1pblNjYWxlO1xyXG4gICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCB8fCAhd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGVudENvbXBvbmVudCB8fCBzY2FsZSA8IG1pblNjYWxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBoYW5kbGVEaXNhYmxlQW5pbWF0aW9uLmNhbGwoX3RoaXMpO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVTdGFydFBhbm5pbmcoZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA9PT0gMilcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVQaW5jaFN0YXJ0KGV2ZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZVRvdWNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHBhbiA9IF9hLnBhbiwgcGluY2ggPSBfYS5waW5jaCwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoIXBhbi5kaXNhYmxlZCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVQYW5uaW5nKGV2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCFwaW5jaC5kaXNhYmxlZCAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMilcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVQaW5jaChldmVudCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5oYW5kbGVUb3VjaFN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVN0b3BQYW5uaW5nKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBpbmNoU3RvcCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIC8vIENvbnRyb2xzXHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIF90aGlzLnpvb21JbiA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLCBfYiA9IF9hLnpvb21JbiwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgc3RlcCA9IF9iLnN0ZXAsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9jLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYy5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJab29tIGluIGZ1bmN0aW9uIHJlcXVpcmVzIGV2ZW50IHByb3BcIik7XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCB8fCBvcHRpb25zLmRpc2FibGVkIHx8ICF3cmFwcGVyQ29tcG9uZW50IHx8ICFjb250ZW50Q29tcG9uZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBoYW5kbGVab29tQ29udHJvbHMuY2FsbChfdGhpcywgMSwgc3RlcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy56b29tT3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIF9iID0gX2Euem9vbU91dCwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgc3RlcCA9IF9iLnN0ZXAsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9jLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYy5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJab29tIG91dCBmdW5jdGlvbiByZXF1aXJlcyBldmVudCBwcm9wXCIpO1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgfHwgb3B0aW9ucy5kaXNhYmxlZCB8fCAhd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGVudENvbXBvbmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaGFuZGxlWm9vbUNvbnRyb2xzLmNhbGwoX3RoaXMsIC0xLCBzdGVwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmhhbmRsZURiQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc3RhdGVQcm92aWRlciwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIF9iID0gX2EuZG91YmxlQ2xpY2ssIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIHN0ZXAgPSBfYi5zdGVwO1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9jLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYy5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEb3VibGUgY2xpY2sgZnVuY3Rpb24gcmVxdWlyZXMgZXZlbnQgcHJvcFwiKTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkIHx8IG9wdGlvbnMuZGlzYWJsZWQgfHwgIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGhhbmRsZURvdWJsZUNsaWNrLmNhbGwoX3RoaXMsIGV2ZW50LCAxLCBzdGVwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnNldFNjYWxlID0gZnVuY3Rpb24gKG5ld1NjYWxlLCBzcGVlZCwgdHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoc3BlZWQgPT09IHZvaWQgMCkgeyBzcGVlZCA9IDIwMDsgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBcImVhc2VPdXRcIjsgfVxyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWSwgc2NhbGUgPSBfYS5zY2FsZSwgZGlzYWJsZWQgPSBfYS5vcHRpb25zLmRpc2FibGVkO1xyXG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9iLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYi5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgfHwgIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRTdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogcG9zaXRpb25YLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25ZOiBwb3NpdGlvblksXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogaXNOYU4obmV3U2NhbGUpID8gc2NhbGUgOiBuZXdTY2FsZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYW5pbWF0ZUNvbXBvbmVudC5jYWxsKF90aGlzLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZTogdGFyZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICBzcGVlZDogc3BlZWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnNldFBvc2l0aW9uWCA9IGZ1bmN0aW9uIChuZXdQb3NYLCBzcGVlZCwgdHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoc3BlZWQgPT09IHZvaWQgMCkgeyBzcGVlZCA9IDIwMDsgfVxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBcImVhc2VPdXRcIjsgfVxyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWSwgc2NhbGUgPSBfYS5zY2FsZSwgX2IgPSBfYS5vcHRpb25zLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCB0cmFuc2Zvcm1FbmFibGVkID0gX2IudHJhbnNmb3JtRW5hYmxlZDtcclxuICAgICAgICAgICAgdmFyIF9jID0gX3RoaXMuc3RhdGUsIHdyYXBwZXJDb21wb25lbnQgPSBfYy53cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50ID0gX2MuY29udGVudENvbXBvbmVudDtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkIHx8ICF0cmFuc2Zvcm1FbmFibGVkIHx8ICF3cmFwcGVyQ29tcG9uZW50IHx8ICFjb250ZW50Q29tcG9uZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0U3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblg6IGlzTmFOKG5ld1Bvc1gpID8gcG9zaXRpb25YIDogbmV3UG9zWCxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWTogcG9zaXRpb25ZLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRlQ29tcG9uZW50LmNhbGwoX3RoaXMsIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlOiB0YXJnZXRTdGF0ZSxcclxuICAgICAgICAgICAgICAgIHNwZWVkOiBzcGVlZCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuc2V0UG9zaXRpb25ZID0gZnVuY3Rpb24gKG5ld1Bvc1ksIHNwZWVkLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7IHNwZWVkID0gMjAwOyB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IFwiZWFzZU91dFwiOyB9XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZLCBfYiA9IF9hLm9wdGlvbnMsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIHRyYW5zZm9ybUVuYWJsZWQgPSBfYi50cmFuc2Zvcm1FbmFibGVkO1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9jLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYy5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgfHwgIXRyYW5zZm9ybUVuYWJsZWQgfHwgIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRTdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogcG9zaXRpb25YLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25ZOiBpc05hTihuZXdQb3NZKSA/IHBvc2l0aW9uWSA6IG5ld1Bvc1ksXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFuaW1hdGVDb21wb25lbnQuY2FsbChfdGhpcywge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGU6IHRhcmdldFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IHNwZWVkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobmV3UG9zWCwgbmV3UG9zWSwgbmV3U2NhbGUsIHNwZWVkLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7IHNwZWVkID0gMjAwOyB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IFwiZWFzZU91dFwiOyB9XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZLCBzY2FsZSA9IF9hLnNjYWxlLCBfYiA9IF9hLm9wdGlvbnMsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIHRyYW5zZm9ybUVuYWJsZWQgPSBfYi50cmFuc2Zvcm1FbmFibGVkO1xyXG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5zdGF0ZSwgd3JhcHBlckNvbXBvbmVudCA9IF9jLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBfYy5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgfHwgIXRyYW5zZm9ybUVuYWJsZWQgfHwgIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRTdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uWDogaXNOYU4obmV3UG9zWCkgPyBwb3NpdGlvblggOiBuZXdQb3NYLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25ZOiBpc05hTihuZXdQb3NZKSA/IHBvc2l0aW9uWSA6IG5ld1Bvc1ksXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogaXNOYU4obmV3U2NhbGUpID8gc2NhbGUgOiBuZXdTY2FsZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYW5pbWF0ZUNvbXBvbmVudC5jYWxsKF90aGlzLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZTogdGFyZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICBzcGVlZDogc3BlZWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLm9wdGlvbnMsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHRyYW5zZm9ybUVuYWJsZWQgPSBfYS50cmFuc2Zvcm1FbmFibGVkO1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgfHwgIXRyYW5zZm9ybUVuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHJlc2V0VHJhbnNmb3JtYXRpb25zLmNhbGwoX3RoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuc2V0RGVmYXVsdFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0ZVByb3ZpZGVyID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLnN0YXRlUHJvdmlkZXIpLCB7IHNjYWxlOiBpbml0aWFsU3RhdGUuc2NhbGUsIHBvc2l0aW9uWDogaW5pdGlhbFN0YXRlLnBvc2l0aW9uWCwgcG9zaXRpb25ZOiBpbml0aWFsU3RhdGUucG9zaXRpb25ZIH0pLCBfdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWVzKTtcclxuICAgICAgICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vLy8vLy8vLy9cclxuICAgICAgICAvLyBTZXR0ZXJzXHJcbiAgICAgICAgLy8vLy8vLy8vL1xyXG4gICAgICAgIF90aGlzLnNldFdyYXBwZXJDb21wb25lbnQgPSBmdW5jdGlvbiAod3JhcHBlckNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHdyYXBwZXJDb21wb25lbnQ6IHdyYXBwZXJDb21wb25lbnQgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5zZXRDb250ZW50Q29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbnRlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBjb250ZW50Q29tcG9uZW50OiBjb250ZW50Q29tcG9uZW50IH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlUHJvdmlkZXIsIHdyYXBwZXJDb21wb25lbnQgPSBfYS53cmFwcGVyQ29tcG9uZW50LCBfYiA9IF9hLm9wdGlvbnMsIGNlbnRlckNvbnRlbnQgPSBfYi5jZW50ZXJDb250ZW50LCBsaW1pdFRvQm91bmRzID0gX2IubGltaXRUb0JvdW5kcywgbGltaXRUb1dyYXBwZXIgPSBfYi5saW1pdFRvV3JhcHBlciwgc2NhbGUgPSBfYS5zY2FsZTtcclxuICAgICAgICAgICAgICAgIHZhciBfYyA9IF90aGlzLnByb3BzLmRlZmF1bHRWYWx1ZXMsIHBvc2l0aW9uWCA9IF9jLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2MucG9zaXRpb25ZO1xyXG4gICAgICAgICAgICAgICAgaWYgKChsaW1pdFRvQm91bmRzICYmICFsaW1pdFRvV3JhcHBlcikgfHxcclxuICAgICAgICAgICAgICAgICAgICAoY2VudGVyQ29udGVudCAmJiAhcG9zaXRpb25YICYmICFwb3NpdGlvblkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKDI1JSwgMjUlKSBzY2FsZShcIiArIHNjYWxlICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvbXBvbmVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudENvbXBvbmVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHRvIGluamVjdCBzdGF0ZSB0byB0aGUgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGltZV8xID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFRpbWVXYWl0XzEgPSAyMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbF8xID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGhhbmRsZUNhbGN1bGF0ZUJvdW5kcy5jYWxsKF90aGlzLCBzY2FsZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVQcm92aWRlci5wb3NpdGlvblggPSBib3VuZHMubWluUG9zaXRpb25YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVQcm92aWRlci5wb3NpdGlvblkgPSBib3VuZHMubWluUG9zaXRpb25ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbihudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbF8xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZV8xID4gbWF4VGltZVdhaXRfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsXzEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbihudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKG5ld1NjYWxlLCBwb3NYLCBwb3NZKSB7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMubW91bnRlZClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRDb21wb25lbnQgPSBfdGhpcy5zdGF0ZS5jb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgICAgICB2YXIgb25ab29tQ2hhbmdlID0gX3RoaXMucHJvcHMub25ab29tQ2hhbmdlO1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5zdGF0ZVByb3ZpZGVyLCBwcmV2aW91c1NjYWxlID0gX2EucHJldmlvdXNTY2FsZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XHJcbiAgICAgICAgICAgIGlmICghY29udGVudENvbXBvbmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiVGhlcmUgaXMgbm8gY29udGVudCBjb21wb25lbnRcIik7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIChwb3NYIHx8IHBvc2l0aW9uWCkgKyBcInB4LCBcIiArIChwb3NZIHx8XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvblkpICsgXCJweCkgc2NhbGUoXCIgKyAobmV3U2NhbGUgfHwgc2NhbGUpICsgXCIpXCI7XHJcbiAgICAgICAgICAgIGNvbnRlbnRDb21wb25lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgICAgICBjb250ZW50Q29tcG9uZW50LnN0eWxlLldlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHRvIGluamVjdCBzdGF0ZSB0byB0aGUgY29udGV4dFxyXG4gICAgICAgICAgICBfdGhpcy5mb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAob25ab29tQ2hhbmdlICYmIHByZXZpb3VzU2NhbGUgIT09IHNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhvblpvb21DaGFuZ2UsIF90aGlzLmdldENhbGxiYWNrUHJvcHMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vLy8vLy8vLy9cclxuICAgICAgICAvLyBQcm9wc1xyXG4gICAgICAgIC8vLy8vLy8vLy9cclxuICAgICAgICBfdGhpcy5nZXRDYWxsYmFja1Byb3BzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0VmFsaWRQcm9wc0Zyb21PYmplY3QoX3RoaXMuc3RhdGVQcm92aWRlcik7IH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhc3NpdmVPcHRpb24gPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKGZhbHNlKTtcclxuICAgICAgICAvLyBQYW5uaW5nIG9uIHdpbmRvdyB0byBhbGxvdyBwYW5uaW5nIHdoZW4gbW91c2UgaXMgb3V0IG9mIHdyYXBwZXJcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZVN0YXJ0UGFubmluZywgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVQYW5uaW5nLCBwYXNzaXZlT3B0aW9uKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVTdG9wUGFubmluZywgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICB9O1xyXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhc3NpdmVPcHRpb24gPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKGZhbHNlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLmhhbmRsZVN0YXJ0UGFubmluZywgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVQYW5uaW5nLCBwYXNzaXZlT3B0aW9uKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVTdG9wUGFubmluZywgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICAgICAgaGFuZGxlRGlzYWJsZUFuaW1hdGlvbi5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChvbGRQcm9wcywgb2xkU3RhdGUpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCB3cmFwcGVyQ29tcG9uZW50ID0gX2Eud3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCA9IF9hLmNvbnRlbnRDb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGR5bmFtaWNWYWx1ZXMgPSB0aGlzLnByb3BzLmR5bmFtaWNWYWx1ZXM7XHJcbiAgICAgICAgaWYgKCFvbGRTdGF0ZS5jb250ZW50Q29tcG9uZW50ICYmIGNvbnRlbnRDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZVByb3ZpZGVyLmNvbnRlbnRDb21wb25lbnQgPSBjb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9sZFN0YXRlLndyYXBwZXJDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgd3JhcHBlckNvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICB3cmFwcGVyQ29tcG9uZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZVByb3ZpZGVyLndyYXBwZXJDb21wb25lbnQgPSB3cmFwcGVyQ29tcG9uZW50O1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd1RvV3JhcHBlclNjYWxlWCA9IGdldFdpbmRvd1NjYWxlWCh3cmFwcGVyQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dUb1dyYXBwZXJTY2FsZVkgPSBnZXRXaW5kb3dTY2FsZVkod3JhcHBlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIC8vIFpvb21pbmcgZXZlbnRzIG9uIHdyYXBwZXJcclxuICAgICAgICAgICAgdmFyIHBhc3NpdmVPcHRpb24gPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKGZhbHNlKTtcclxuICAgICAgICAgICAgd3JhcHBlckNvbXBvbmVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5oYW5kbGVXaGVlbCwgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICAgICAgICAgIHdyYXBwZXJDb21wb25lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuaGFuZGxlRGJDbGljaywgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICAgICAgICAgIHdyYXBwZXJDb21wb25lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCBwYXNzaXZlT3B0aW9uKTtcclxuICAgICAgICAgICAgd3JhcHBlckNvbXBvbmVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuaGFuZGxlVG91Y2gsIHBhc3NpdmVPcHRpb24pO1xyXG4gICAgICAgICAgICB3cmFwcGVyQ29tcG9uZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZVRvdWNoU3RvcCwgcGFzc2l2ZU9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBib3VuZCBmb3IgYW5pbWF0aW9uc1xyXG4gICAgICAgIGlmICgod3JhcHBlckNvbXBvbmVudCAmJiBjb250ZW50Q29tcG9uZW50KSB8fFxyXG4gICAgICAgICAgICBvbGRQcm9wcy5keW5hbWljVmFsdWVzICE9PSBkeW5hbWljVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4Qm91bmRzID0gaGFuZGxlQ2FsY3VsYXRlQm91bmRzLmNhbGwodGhpcywgdGhpcy5zdGF0ZVByb3ZpZGVyLnNjYWxlLCB0aGlzLnN0YXRlUHJvdmlkZXIub3B0aW9ucy5saW1pdFRvV3JhcHBlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG11c3QgYmUgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZ1bmN0aW9uLCB1cGRhdGVzXHJcbiAgICAgICAgaWYgKG9sZFByb3BzLmR5bmFtaWNWYWx1ZXMgJiYgb2xkUHJvcHMuZHluYW1pY1ZhbHVlcyAhPT0gZHluYW1pY1ZhbHVlcykge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVQcm92aWRlciA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLnN0YXRlUHJvdmlkZXIpLCBtZXJnZVByb3BzKHRoaXMuc3RhdGVQcm92aWRlciwgZHluYW1pY1ZhbHVlcykpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24obnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCB3cmFwcGVyQ29tcG9uZW50ID0gX2Eud3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCA9IF9hLmNvbnRlbnRDb21wb25lbnQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGV4dCBwcm92aWRlciB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHtcclxuICAgICAgICAgICAgbG9hZGVkOiBCb29sZWFuKHdyYXBwZXJDb21wb25lbnQgJiYgY29udGVudENvbXBvbmVudCksXHJcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmdldENhbGxiYWNrUHJvcHMoKSxcclxuICAgICAgICAgICAgZGlzcGF0Y2g6IHtcclxuICAgICAgICAgICAgICAgIHNldFNjYWxlOiB0aGlzLnNldFNjYWxlLFxyXG4gICAgICAgICAgICAgICAgc2V0UG9zaXRpb25YOiB0aGlzLnNldFBvc2l0aW9uWCxcclxuICAgICAgICAgICAgICAgIHNldFBvc2l0aW9uWTogdGhpcy5zZXRQb3NpdGlvblksXHJcbiAgICAgICAgICAgICAgICB6b29tSW46IHRoaXMuem9vbUluLFxyXG4gICAgICAgICAgICAgICAgem9vbU91dDogdGhpcy56b29tT3V0LFxyXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNmb3JtOiB0aGlzLnNldFRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhbnNmb3JtOiB0aGlzLnJlc2V0VHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgc2V0RGVmYXVsdFN0YXRlOiB0aGlzLnNldERlZmF1bHRTdGF0ZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZXM6IHtcclxuICAgICAgICAgICAgICAgIHNldFdyYXBwZXJDb21wb25lbnQ6IHRoaXMuc2V0V3JhcHBlckNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIHNldENvbnRlbnRDb21wb25lbnQ6IHRoaXMuc2V0Q29udGVudENvbXBvbmVudCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIlxyXG4gICAgICAgICAgICA/IGNoaWxkcmVuKF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YWx1ZS5zdGF0ZSksIHZhbHVlLmRpc3BhdGNoKSlcclxuICAgICAgICAgICAgOiBjaGlsZHJlbjtcclxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSB9LCBjb250ZW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RhdGVQcm92aWRlcjtcclxufShDb21wb25lbnQpKTtcblxudmFyIFRyYW5zZm9ybVdyYXBwZXIgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBkZWZhdWx0UG9zaXRpb25YID0gX2EuZGVmYXVsdFBvc2l0aW9uWCwgZGVmYXVsdFBvc2l0aW9uWSA9IF9hLmRlZmF1bHRQb3NpdGlvblksIGRlZmF1bHRTY2FsZSA9IF9hLmRlZmF1bHRTY2FsZSwgb25XaGVlbFN0YXJ0ID0gX2Eub25XaGVlbFN0YXJ0LCBvbldoZWVsID0gX2Eub25XaGVlbCwgb25XaGVlbFN0b3AgPSBfYS5vbldoZWVsU3RvcCwgb25QYW5uaW5nU3RhcnQgPSBfYS5vblBhbm5pbmdTdGFydCwgb25QYW5uaW5nID0gX2Eub25QYW5uaW5nLCBvblBhbm5pbmdTdG9wID0gX2Eub25QYW5uaW5nU3RvcCwgb25QaW5jaGluZ1N0YXJ0ID0gX2Eub25QaW5jaGluZ1N0YXJ0LCBvblBpbmNoaW5nID0gX2Eub25QaW5jaGluZywgb25QaW5jaGluZ1N0b3AgPSBfYS5vblBpbmNoaW5nU3RvcCwgb25ab29tQ2hhbmdlID0gX2Eub25ab29tQ2hhbmdlLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImRlZmF1bHRQb3NpdGlvblhcIiwgXCJkZWZhdWx0UG9zaXRpb25ZXCIsIFwiZGVmYXVsdFNjYWxlXCIsIFwib25XaGVlbFN0YXJ0XCIsIFwib25XaGVlbFwiLCBcIm9uV2hlZWxTdG9wXCIsIFwib25QYW5uaW5nU3RhcnRcIiwgXCJvblBhbm5pbmdcIiwgXCJvblBhbm5pbmdTdG9wXCIsIFwib25QaW5jaGluZ1N0YXJ0XCIsIFwib25QaW5jaGluZ1wiLCBcIm9uUGluY2hpbmdTdG9wXCIsIFwib25ab29tQ2hhbmdlXCJdKTtcclxuICAgIHZhciBwcm9wcyA9IF9fYXNzaWduKHt9LCByZXN0KTtcclxuICAgIGlmIChwcm9wcy5vcHRpb25zICYmIHByb3BzLm9wdGlvbnMubGltaXRUb1dyYXBwZXIpIHtcclxuICAgICAgICBwcm9wcy5vcHRpb25zLmxpbWl0VG9Cb3VuZHMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRlUHJvdmlkZXIsIHsgZGVmYXVsdFZhbHVlczogZGVsZXRlVW5kZWZpbmVkUHJvcHMoe1xyXG4gICAgICAgICAgICBwb3NpdGlvblg6IGRlZmF1bHRQb3NpdGlvblgsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uWTogZGVmYXVsdFBvc2l0aW9uWSxcclxuICAgICAgICAgICAgc2NhbGU6IGRlZmF1bHRTY2FsZSxcclxuICAgICAgICB9KSwgZHluYW1pY1ZhbHVlczogZGVsZXRlVW5kZWZpbmVkUHJvcHMoZ2V0VmFsaWRQcm9wc0Zyb21PYmplY3QocHJvcHMpKSwgb25XaGVlbFN0YXJ0OiBvbldoZWVsU3RhcnQsIG9uV2hlZWw6IG9uV2hlZWwsIG9uV2hlZWxTdG9wOiBvbldoZWVsU3RvcCwgb25QYW5uaW5nU3RhcnQ6IG9uUGFubmluZ1N0YXJ0LCBvblBhbm5pbmc6IG9uUGFubmluZywgb25QYW5uaW5nU3RvcDogb25QYW5uaW5nU3RvcCwgb25QaW5jaGluZ1N0YXJ0OiBvblBpbmNoaW5nU3RhcnQsIG9uUGluY2hpbmc6IG9uUGluY2hpbmcsIG9uUGluY2hpbmdTdG9wOiBvblBpbmNoaW5nU3RvcCwgb25ab29tQ2hhbmdlOiBvblpvb21DaGFuZ2UgfSwgY2hpbGRyZW4pKTtcclxufTtcblxuZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgY3NzID0gXCIuVHJhbnNmb3JtQ29tcG9uZW50LW1vZHVsZV9jb250YWluZXJfXzNOd05kIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiBmaXQtY29udGVudDtcXG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyAvKiBpT1MgU2FmYXJpICovXFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAvKiBTYWZhcmkgKi9cXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTsgLyogS29ucXVlcm9yIEhUTUwgKi9cXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEZpcmVmb3ggKi9cXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTsgLyogSW50ZXJuZXQgRXhwbG9yZXIvRWRnZSAqL1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4uVHJhbnNmb3JtQ29tcG9uZW50LW1vZHVsZV9jb250ZW50X19UWlU1TyB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcXG59XFxuLlRyYW5zZm9ybUNvbXBvbmVudC1tb2R1bGVfY29udGVudF9fVFpVNU8gaW1nIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cIjtcbnZhciBzdHlsZXMgPSB7XCJjb250YWluZXJcIjpcIlRyYW5zZm9ybUNvbXBvbmVudC1tb2R1bGVfY29udGFpbmVyX18zTndOZFwiLFwiY29udGVudFwiOlwiVHJhbnNmb3JtQ29tcG9uZW50LW1vZHVsZV9jb250ZW50X19UWlU1T1wifTtcbnN0eWxlSW5qZWN0KGNzcyk7XG5cbnZhciBUcmFuc2Zvcm1Db21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVHJhbnNmb3JtQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLndyYXBwZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcclxuICAgICAgICBfdGhpcy5jb250ZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgVHJhbnNmb3JtQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmNvbnRleHQubm9kZXM7XHJcbiAgICAgICAgbm9kZXMuc2V0V3JhcHBlckNvbXBvbmVudCh0aGlzLndyYXBwZXJSZWYuY3VycmVudCk7XHJcbiAgICAgICAgbm9kZXMuc2V0Q29udGVudENvbXBvbmVudCh0aGlzLmNvbnRlbnRSZWYuY3VycmVudCk7XHJcbiAgICB9O1xyXG4gICAgVHJhbnNmb3JtQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQuc3RhdGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZLCBzY2FsZSA9IF9hLnNjYWxlLCBfYiA9IF9hLm9wdGlvbnMsIHdyYXBwZXJDbGFzcyA9IF9iLndyYXBwZXJDbGFzcywgY29udGVudENsYXNzID0gX2IuY29udGVudENsYXNzO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHtcclxuICAgICAgICAgICAgV2Via2l0VHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHBvc2l0aW9uWCArIFwicHgsIFwiICsgcG9zaXRpb25ZICsgXCJweCkgc2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgcG9zaXRpb25YICsgXCJweCwgXCIgKyBwb3NpdGlvblkgKyBcInB4KSBzY2FsZShcIiArIHNjYWxlICsgXCIpXCIsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMud3JhcHBlclJlZiwgY2xhc3NOYW1lOiBcInJlYWN0LXRyYW5zZm9ybS1jb21wb25lbnQgXCIgKyBzdHlsZXMuY29udGFpbmVyICsgXCIgXCIgKyB3cmFwcGVyQ2xhc3MgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5jb250ZW50UmVmLCBjbGFzc05hbWU6IFwicmVhY3QtdHJhbnNmb3JtLWVsZW1lbnQgXCIgKyBzdHlsZXMuY29udGVudCArIFwiIFwiICsgY29udGVudENsYXNzLCBzdHlsZTogc3R5bGUgfSwgY2hpbGRyZW4pKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyYW5zZm9ybUNvbXBvbmVudDtcclxufShSZWFjdC5Db21wb25lbnQpKTtcclxuVHJhbnNmb3JtQ29tcG9uZW50LmNvbnRleHRUeXBlID0gQ29udGV4dDtcblxuZXhwb3J0IHsgVHJhbnNmb3JtQ29tcG9uZW50LCBUcmFuc2Zvcm1XcmFwcGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-zoom-pan-pinch/dist/index.es.js\n");

/***/ })

})