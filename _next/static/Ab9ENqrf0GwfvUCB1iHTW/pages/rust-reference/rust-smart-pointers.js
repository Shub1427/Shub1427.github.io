(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{"0Hkh":function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n("Q88C"),r={"rust-cargo-basics":{key:"rust-cargo-basics",link:"/rust-reference/rust-cargo-basics",title:"Basics on Rust & Cargo",description:"Basics on Rust & Cargo",ogImage:"https://user-images.githubusercontent.com/11786283/81770497-0c77c000-94fe-11ea-95bc-44e5e432b1d8.jpg",tags:[a.a.RUST],createdAt:new Date("2020/04/26 22:00:00"),updatedAt:new Date("2020/04/26 22:00:00"),isPublished:!0},"rust-smart-pointers":{key:"rust-smart-pointers",link:"/rust-reference/rust-smart-pointers",title:"Smart Pointers",description:"Some notes on Box<>, Rc<>, RefCell<> etc.",ogImage:"https://user-images.githubusercontent.com/11786283/81770497-0c77c000-94fe-11ea-95bc-44e5e432b1d8.jpg",tags:[a.a.RUST],createdAt:new Date("2020/05/22 17:45:00"),updatedAt:new Date("2020/05/22 17:45:00"),isPublished:!0}}},"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n("q1tI"),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var b=r.a.createContext({}),s=function(e){var t=r.a.useContext(b),n=t;return e&&(n="function"===typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=s(e.components);return(r.a.createElement(b.Provider,{value:t},e.children))},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),p=s(n),u=a,d=p["".concat(i,".").concat(u)]||p[u]||m[u]||o;return n?r.a.createElement(d,l({ref:t},b,{components:n})):r.a.createElement(d,l({ref:t},b))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[u]="string"===typeof e?e:a,i[1]=l;for(var b=2;b<o;b++)i[b]=n[b];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},Ff2n:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var a=n("zLVn");function r(e,t){if(null==e)return{};var n,r,o=Object(a.a)(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}},Q88C:function(e,t,n){"use strict";var a;n.d(t,"a",(function(){return a})),function(e){e.TUTORIAL="tutorial",e.PROJECT="project",e.RESEARCH="research",e.RUST="rust",e.JS="javascript",e.REACT="reactjs",e.GFX_HAL="gfx-hal"}(a||(a={}))},Qetd:function(e,t,n){"use strict";var a=Object.assign.bind(Object);e.exports=a,e.exports.default=e.exports},UN7r:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/rust-reference/rust-smart-pointers",function(){return n("ufU9")}])},ufU9:function(e,t,n){"use strict";n.r(t),n.d(t,"record",(function(){return b})),n.d(t,"default",(function(){return j}));var a=n("wx14"),r=n("Ff2n"),o=n("q1tI"),i=n.n(o),l=n("7ljp"),c=n("0Hkh"),b=(i.a.createElement,c.a["rust-smart-pointers"]),s=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(l.b)("div",t)}},p=s("PolkaContainer"),u=s("H1"),m=s("Blockquote"),d=s("InlineCode"),h={record:b},O="wrapper";function j(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(l.b)(O,Object(a.a)({},h,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)(p,{pageTitle:b.title,pageDescription:b.description,keywords:["Advance Rust"],publishDate:b.createdAt,ogImage:b.ogImage,mdxType:"PolkaContainer"},Object(l.b)(u,{updatedAt:b.updatedAt,mdxType:"H1"},b.title),Object(l.b)("p",null,"Smart Pointers are normal structs, but they ",Object(l.b)("inlineCode",{parentName:"p"},"impl"),"\n",Object(l.b)("inlineCode",{parentName:"p"},"Deref")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Drop")," traits, so as to work exactly like\nregular pointers. ",Object(l.b)("inlineCode",{parentName:"p"},"Deref")," trait helps Smart Pointers to be\nallowed to dereferenced like regular pointers, i.e like\n",Object(l.b)("inlineCode",{parentName:"p"},"*x"),", where ",Object(l.b)("inlineCode",{parentName:"p"},"x")," is a pointer. ",Object(l.b)("inlineCode",{parentName:"p"},"Drop")," helps to memory\nmanage the resource Smart Pointers are pointing to, they\nare like destructors in ",Object(l.b)("inlineCode",{parentName:"p"},"C++"),"."),Object(l.b)("h2",null,Object(l.b)("inlineCode",{parentName:"h2"},"Box<T>")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Box<T>")," is very similar to regular pointers, but they can\nstore any type in themselves. Also, ",Object(l.b)("inlineCode",{parentName:"p"},"Box<T>")," owns the data\nthat it points to."),Object(l.b)("h3",null,"When to use ",Object(l.b)("inlineCode",{parentName:"h3"},"Box<T>")),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"I am directly quoting this from ",Object(l.b)("a",Object(a.a)({parentName:"em"},{href:"https://doc.rust-lang.org/book/ch15-01-box.html"}),"Rust Book"))),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"When you have a type whose size can\u2019t be known at compile\ntime and you want to use a value of that type in a\ncontext that requires an exact size"),Object(l.b)("li",{parentName:"ol"},"When you have a large amount of data and you want to\ntransfer ownership but ensure the data won\u2019t be copied\nwhen you do so."),Object(l.b)("li",{parentName:"ol"},"When you want to own a value and you care only that\nit\u2019s a type that implements a particular trait rather\nthan being of a specific type.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"For Part 1.")," Recursive Types like, Linked List requires\nto have Nodes that points itself, where getting a size of\nNode is impossible on Compile Time, ",Object(l.b)("inlineCode",{parentName:"p"},"Box<T>")," can be used."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Box<T>")," is already a part of ",Object(l.b)("inlineCode",{parentName:"p"},"std::prelude"),", thus\nit doesn't has to be imported explicitly from ",Object(l.b)("inlineCode",{parentName:"p"},"std::boxed::Box"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rs"}),'struct Node {\n  id: usize,\n  name: String,\n  role: String,\n}\n\n// Now we need to create Box<Node>, like any other object\nlet node: Box<Node> = Box::new(Node {\n  id: 1,\n  name: "Harry".to_owned(),\n  role: "CHOSEN_ONE".to_owned()\n})\n\n// We can use above `node`, like any other object\nprintln!("Node:: {:?}", node.name);\n')),Object(l.b)("p",null,"Do remember, ",Object(l.b)("inlineCode",{parentName:"p"},"C")," and ",Object(l.b)("inlineCode",{parentName:"p"},"C++")," required memory managed pointers,\nbut in Rust we don't have to explicitly manage Pointers and\nthere data. Rust handles it internally using ownership/lifetime\nspecs. This applies to Smart Pointers as well."),Object(l.b)("h2",null,Object(l.b)("inlineCode",{parentName:"h2"},"Rc<T>")," (Reference Counter)"),Object(l.b)("p",null,"As the name suggests, ",Object(l.b)("inlineCode",{parentName:"p"},"Rc<T>")," smart pointer stores a count\nof pointers to actual data. If count goes to zero, the\nvalue can be cleaned up without any references becoming invalid."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Rc<T>")," is only for use in single-threaded scenarios."),Object(l.b)("p",null,"Should be imported from ",Object(l.b)("inlineCode",{parentName:"p"},"std::rc::Rc"),"."),Object(l.b)("h3",null,"When to use ",Object(l.b)("inlineCode",{parentName:"h3"},"Rc<T>")),Object(l.b)("p",null,"I will explain this with a practical example first."),Object(l.b)("p",null,"Let's say I have an ",Object(l.b)("inlineCode",{parentName:"p"},"Ball")," instance, which needs to be\nsaved into two different ",Object(l.b)("inlineCode",{parentName:"p"},"List"),". In ",Object(l.b)("inlineCode",{parentName:"p"},"JS"),", we would've done\nsomething like:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"let b1 = new Ball();\nlet list1 = new List();\nlet list2 = new List();\n\nlist1.add(b1);\nlist2.add(b1);\n")),Object(l.b)("p",null,"So simple right, but if you look closely, ",Object(l.b)("inlineCode",{parentName:"p"},"b1")," is the same\nin ",Object(l.b)("inlineCode",{parentName:"p"},"list1")," and ",Object(l.b)("inlineCode",{parentName:"p"},"list2"),", so if ",Object(l.b)("inlineCode",{parentName:"p"},"b1")," changes in ",Object(l.b)("inlineCode",{parentName:"p"},"list1"),", it\nwill change in ",Object(l.b)("inlineCode",{parentName:"p"},"list2")," as well, as JS creates mutable objects\nby default."),Object(l.b)("p",null,"We can solve this, but that is not our concern here right now.\nThe main point behind showing this example was, that ",Object(l.b)("inlineCode",{parentName:"p"},"list1"),"\nand ",Object(l.b)("inlineCode",{parentName:"p"},"list2")," both have shared references to same resource,\nand can read them simultaneously (considering ",Object(l.b)("inlineCode",{parentName:"p"},"JS")," was not\nsingle threaded). Internally JS engine would be duplicating\nthe pointers to ",Object(l.b)("inlineCode",{parentName:"p"},"b1")," object when passed to ",Object(l.b)("inlineCode",{parentName:"p"},"list1")," and ",Object(l.b)("inlineCode",{parentName:"p"},"list2"),"\n, and the Memory would be managed by the GC. Rust doesn't has\nany GC and thus to manage multiple pointers to single resource\nwe need ",Object(l.b)("inlineCode",{parentName:"p"},"Rc<T>"),"."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},Object(l.b)("inlineCode",{parentName:"p"},"Box<T>")," owns the resource, thus sharing the data between\ntwo parents is not possible. For such cases ",Object(l.b)("inlineCode",{parentName:"p"},"Rc<T>"),"\ncan be used.")),Object(l.b)("p",null,"So, we can write the same thing above in Rust, as follows:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rs"}),"let b1 = Rc::new(Ball::new());\nlet list1 = List::new();\nlet list2 = List::new();\n\nlist1.add(Rc::clone(&b1));\nlist1.add(Rc::clone(&b2));\n")),Object(l.b)("p",null,"Above example would have defined ",Object(l.b)("inlineCode",{parentName:"p"},"List")," type,\nsomething like below:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rs"}),"struct List {\n  ball: Rc<Ball>,\n}\n")),Object(l.b)("p",null,"The call to ",Object(l.b)("inlineCode",{parentName:"p"},"Rc::clone")," only increments the reference\ncount, which doesn\u2019t take much time."),Object(l.b)("h2",null,Object(l.b)("inlineCode",{parentName:"h2"},"RefCell<T>")),Object(l.b)("h3",null,"Concept of ",Object(l.b)("em",{parentName:"h3"},"Interior mutability")),Object(l.b)("p",null,Object(l.b)("em",{parentName:"p"},"Interior mutability")," is a pattern in Rust, where immutable\ndata are allowed to mutate."),Object(l.b)(m,{type:"warn",mdxType:"Blockquote"},Object(l.b)(d,{mdxType:"InlineCode"},"RefCell<T>")," gives us power of mutability in immutable pointers in Rust, but this should be used carefully, because if misused, compiler will not throw errors and programs might crash or have memory leaks, just like ",Object(l.b)(d,{mdxType:"InlineCode"},"C"),"or ",Object(l.b)(d,{mdxType:"InlineCode"},"C++")," programs"),Object(l.b)("p",null,"Can be imported using ",Object(l.b)("inlineCode",{parentName:"p"},"std::cell::RefCell"),"."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"RefCell<T>")," follow all rules defined in Rust for pointers,\nbut in runtime. Thus, using two ",Object(l.b)("em",{parentName:"p"},"mutable")," references in same\nscope will result in Program to panic at runtime."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"RefCell<T>")," lets us have many immutable borrows or one\nmutable borrow at any point in time."),Object(l.b)("p",null,"Above is possible, because ",Object(l.b)("inlineCode",{parentName:"p"},"RefCell<T>")," keeps a count on\nhow many mutable or immutable references are present in a\nscope, thus having more than one mutable reference panics.\nThe counter for ",Object(l.b)("inlineCode",{parentName:"p"},"RefCell<T>")," works similar to reference\ncounting."),Object(l.b)("h3",null,"Let's Code"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rs"}),'let x: RefCell<Vec<String>> = RefCell::new(vec![\n  "Abra".to_owned(),\n  "Kadabra".to_owned(),\n]);\n\n// We can now use it, have n number of immutable references\nx.borrow().get(0);\nx.borrow().get(1);\n\n// But only one mutable reference at a time.\nx.borrow_mut().push("Expelliarmus");\n')),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},".borrow()")," gives us ",Object(l.b)("inlineCode",{parentName:"p"},"Ref<T>")," object, which is an immutable\nsmart pointer."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},".borrow_mut()")," gives us ",Object(l.b)("inlineCode",{parentName:"p"},"RefMut<T>")," object, which is a\nmutable smart pointer."),Object(l.b)("h2",null,"Using ",Object(l.b)("inlineCode",{parentName:"h2"},"Rc<T>")," and ",Object(l.b)("inlineCode",{parentName:"h2"},"RefCell<T>")," together"),Object(l.b)("p",null,"Do you want ",Object(l.b)("inlineCode",{parentName:"p"},"C")," or ",Object(l.b)("inlineCode",{parentName:"p"},"C++")," mutable pointers, which can be\npassed around freely in your application code."),Object(l.b)("p",null,"Enters ",Object(l.b)("inlineCode",{parentName:"p"},"Rc<RefCell<T>>")," \ud83d\ude1c"),Object(l.b)(m,{type:"warn",mdxType:"Blockquote"},Object(l.b)("b",null,"Important:")," Having multiple mutable references present across the code-base can lead to inconsistencies, if not used properly. Though, I think using ",Object(l.b)(d,{mdxType:"InlineCode"},"RefCell<T>"),"and ",Object(l.b)(d,{mdxType:"InlineCode"},"Rc<T>")," together will result in program to panic, giving a heads up on the issue."),Object(l.b)("p",null,"This provides us with N number of Mutable/Immutable\nreferences in any scope. We get a value that can have\nmultiple owners and that we can mutate!"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-rs"}),'let v1 = Rc::new(RefCell::new(5));\nlet v2 = Rc::clone(&v1);\n\n// Now we can break rules, have more than one mutable reference to same memory location,\n// in this example it\'s usize value `5`.\n*v1.borrow_mut() += 10;\n*v2.borrow_mut() += 10;\n\nprintln!("Actual Value now = {:?}", v1); // 25\n')),Object(l.b)("h2",null,"Cautions"),Object(l.b)("p",null,"I am not writing on this, as even I will have to refer\nto ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"}),"Rust Memory Leaks"),"\nevery now and then to understand it better."),Object(l.b)("hr",null),Object(l.b)("p",null,"You can find the Code\n",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Shub1427/rustschool/blob/master/rust-book/smart-pointers/src/main.rs"}),"here"))))}j.isMDXComponent=!0},wx14:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return a}))},zLVn:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}n.d(t,"a",(function(){return a}))}},[["UN7r",0,1]]]);